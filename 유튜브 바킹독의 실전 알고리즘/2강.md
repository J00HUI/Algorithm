## 2강 기초 코드 작성 요령 2

<img src="https://user-images.githubusercontent.com/83942393/135801933-d1bab633-f481-4041-9143-adbffa70ba57.png" width="80%"></img></br>

<img src="https://user-images.githubusercontent.com/83942393/135802018-bb66a3c9-7dcc-4876-91e2-d7bfc9cdcdae.png" width="80%"></img></br>
- 3개의 코드를 보고 출력을 예측해보세요.
- 어떤 부분에 대한걸 물어보는 건지 알겠죠?
- 함수의 인자로 int / int 배열 / 구조체를 실어보내서 값을 바꿨을 때 원본의 값이 바뀌는 지를 물어보는 것입니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/135802172-618cb830-46b2-4d6d-ab55-5c39cdca9dd2.png" width="80%"></img></br>
- c언어를 배울 때, 관련된 얘기를 하면서 두 변수를 swap하는 함수를 만드는 방법도 아마 배웠을 것입니다. 
- swap1 함수는 제대로 동작하지 않고, swap2 함수처럼 포인터를 보내서 두 변수의 값을 바꿀 수 있습니다. 
- C++에서는 해결법이 한 개 더 있는데, 바로 참조자(reference)입니다. 
- 참조자는 C에서의 포인터와 거의 비슷한 기능을 하지만, 포인터에서 Null pointer에 값을 넣는다건가, type이 다른걸 마음대로 캐스팅한다거나 하는 문제들을 덜 할 수 있게 하는 패러다임입니다. 

<img src="https://user-images.githubusercontent.com/83942393/135802452-4faa9356-bdd5-4fc4-a52a-7954d8c4b22e.png" width="80%"></img></br>
- 답은 0입니다.
- STL도 구조체와 비슷하게 함수 인자로 실어 보내면 복사본을 만들어 보내기 때문에 func1 함수에서 바꾼건 원본에 영향을 주지 않습니다. 

<img src="https://user-images.githubusercontent.com/83942393/135802537-9fc7003a-7283-404e-93a5-888769e3bdc1.png" width="80%"></img></br>
- STL을 쌩으로 함수 인자에 넣으면 복사해서 보낸다는 것을 꼭 유의하셔야 합니다. 
- 두 vector의 크기가 N이라고 할 때 이 함수의 시간 복잡도는 얼마일까요?
</br>

- 시간복잡도는 충격적이게도 O(N)이 됩니다.
- 아니 함수 안에 연산을 딱 1번만 하는데 O(N)이라는게 무슨 말도 안되는 소리냐라는 생각이 들 수 있지만, v1, v2에 인자로 실어 보낼 때, 원본으로부터 복사본을 만드는 비용을 생각하지 못하고 계신 것입니다. 
- v1, v2의 크기가 N 이니까 N 개의 원소들을 하나씩 복사하는 과정은 O(N)이 듭니다.
- 그래서 이 함수는 의도치 않게 시간복잡도가 O(N)이 됩니다. 

<img src="https://user-images.githubusercontent.com/83942393/135802808-2f686fbf-79f1-43a8-ad2e-98814bced045.png" width="80%"></img></br>
- 이럴 때 참조자를 이용하면, 복사본을 따로 만들어내지 않고, 참조 대상의 주소 정보만 넘어가기 때문에 시간 복잡도는 의도한대로 O(1)이 됩니다. 

<img src="https://user-images.githubusercontent.com/83942393/135802942-c475ee1e-5817-4832-bc8e-e320ba413789.png" width="80%"></img></br>
- 이번에는 표준 입출력에 대해 다루겠습니다. 
- scanf/printf에서 한 가지 아쉬운 점이라고 한다면, C++ string을 처리할 수 없습니다.
- 아시다시피 c에서는 char* 으로 문자열을 다루는데 사실 char* 보다 c++ string이 월등하게 편리합니다. 
- 그래서 scanf/printf을 쓰면서도 c++string 을 활용하고 싶으면 일단 char* 으로 입력을 받고 string으로 형 변환을 해서 원하는 작업을 다 끝낸 후에, c_str() 메소드를 이용해 출력하면 됩니다. 

<img src="https://user-images.githubusercontent.com/83942393/135803157-dbf543e0-e6f1-4330-a3cf-fb28e9089711.png" width="80%"></img></br>
- scanf를 쓰든 cin을 쓰든 주의해야 할 것이 있는데, scanf와 cin 모두 공백을 포함한 문자열을 입력받을 때 굉장히 껄끄럽습니다.
- 코드를 보시면 알겠지만, 둘 다 공백 앞까지만 입력을 받기 떄문입니다. 
</br>

- 해결책으로는 세 가지가 있는데, 세 번째 getline이 가장 사용하기 편리해보입니다. 
- 아무튼 공백이 포함되니 문자열을 받아야 할 때, 단순히 scanf나 cin을 쓰면 안된다는 걸 꼭 기억해주셔야 합니다. 

<img src="https://user-images.githubusercontent.com/83942393/135803385-519c3910-f449-401b-a109-c02e646d6b8e.png" width="80%"></img></br>
- scanf/printf와 다르게 cin/cout은 입출력으로 인한 시간 초과를 막기 위해, 위의 두 명령을 실행시켜야 합니다. 
- 두 명령이 뭐하는 명령인지 몰라도 상관없지만, 그래도 알아서 나쁠건 없으니 알려드리겠습니다. 
</br>

- 기본적으로 scanf/printf 등에서 사용하는 cstream과 cin/cout 등에서 쓰는 c++ stream은 분리가 되어있습니다.
- 그런데, 지금 코드처럼 printf 와 cout 을 번갈아 사용하는 상황을 생각해보면, 사용자 입장에서는 c stream 과 c++ stream이 분리되어있는 것과는 상관없이 11111, 22222, 3333이 차례로 출력되길 원할 것입니다. 
</br>

- 이렇게 코드의 흐름과 실제 출력이 동일하기 위해서 기본적으로 프로그램에서는 c++ stream과 c stream을 동기화하고 있습니다.
- 그런데, 내가 c++ stream만 쓸거면 굳이 두 stream 을 동기화하고 있을 필요가 없게 됩니다. 쓸데 없이 시간만 잡아먹으니까요.
</br>

- 그렇기 때문에 c++ stream 만 쓸거면 동기화를 끊어버려서 프로그램 수행 시간에서 이득을 챙길 수 있습니다.
- 이 명령은 sync_with_stdio(0) 입니다.
- 엄밀히 말하면 인자가 bool type이라 sync_with_stdio(false)가 더 맞습니다. 
</br>

- 대신 동기화를 끊는다면, cout 과 printf를 섞어쓰면 안됩니다. 섞어쓰게 된다면 지금의 코드 출력 결과처럼 출력 순서가 꼬이게 됩니다.
- 참고로 visual studio 2017/2019에서는 sync_with_studio를 무시하고 무조건 동기화를 유지하고 있기 때문에 변화가 없을 것입니다. 
- 하지만 채점 서버는 gcc이기 때문에 분명히 차이가 있습니다. 
</br>

- 두 번째 명령인 cin.tie(0)을 이해하려면 버퍼라는 개념을 이해해야 합니다.
- 일단 저희가 화면에 아무 글자가 출력을 하는 걸 생각해보면, 한 글자 한 글자 바로 화면에 보이는 것이 아닙니다. 

<img src="https://user-images.githubusercontent.com/83942393/135804234-57c35e08-2422-4d39-b6d0-99d14853ea50.png" width="80%"></img></br>
<img src="https://user-images.githubusercontent.com/83942393/135804238-0f7f2805-1739-45e1-a1a9-a2ecf7bbe0bf.png" width="80%"></img></br>
<img src="https://user-images.githubusercontent.com/83942393/135804248-4203af61-b558-4857-85c6-b1f3a0044b84.png" width="80%"></img></br>
<img src="https://user-images.githubusercontent.com/83942393/135804256-27d2f1ee-0fbb-4dc4-9158-a9acc724bc65.png" width="80%"></img></br>
- 그렇지 않고, 출력 버퍼에 문자가 임시로 저장되어 있다가 버퍼가 비워지면서 화면에 보입니다. 
</br>

- 출력 버퍼가 있는 것처럼, 입력 버퍼가 있어서 키보드로 입력을 받을 때도, 바로바로 넘겨주지 않고 버퍼에 어느 정도 모았다가 보냅니다.

<img src="https://user-images.githubusercontent.com/83942393/135804478-634dc874-f92b-4cbc-a653-e09cc7d9cb8a.png" width="80%"></img></br>
- 그런데, 입력과 출력이 번갈아 나오고 그게 한 화면에서 전부 보여질 경우에는 버퍼의 존재로 인해 순서가 꼬일 수 있습니다. 
- 이런 현상을 막기 위해 기본적으로 cin 명령을 수행하기 전에 cout 버퍼를 비워줍니다. 
- 버퍼를 비우면 자연스럽게 "2 5" 입력 전에 118이 출력이 되어 순서가 꼬이지 않게 됩니다. 
</br>

- 하지만, 온라인 저지 사이트에서는 채점을 할 때 출력 글자만 확인합니다. 
- 그렇기 때문에 콘솔 창에서 입력 글자와 출력 글자 사이에 순서가 설령 꼬인다고 해도 채점에 아무런 영향을 주지 않고, 두 경우 모두 정답 처리가 됩니다.
- 그러면 굳이 cin 명령을 수행하기 전에 cout 버퍼를 비울 필요가 없으므로, cin.tie(nullptr)이며, 엄밀히는 type 을 지켜 nullptr을 쓰는게 좋지만, 0이라고 써도 상관 없습니다. 

<img src="https://user-images.githubusercontent.com/83942393/135804897-81009f70-4118-4f91-81de-562c60f62688.png" width="80%"></img></br>
- 앞서 얘기했듯이, 저지는 프로그램이 종료될 때 출력이 어떻게 생겼는지를 가지고 채점을 하기 때문에, 중간 중간 버퍼를 비우라고 명령을 할 필요가 없습니다. 
- 줄바꿈이 필요하다면 endl 대신 개행문자를 출력하시면 됩니다. 

<img src="https://user-images.githubusercontent.com/83942393/135805102-e097f425-9b1c-44e8-be3e-54a26d662f5e.png" width="80%"></img></br>
- 이제 여러분이 코딩테스트를 볼 때 도움이 많이 될 코드 작성 팁을 알려드리겠습니다.
- [BOJ 10871번: X보다 작은 수](https://www.acmicpc.net/problem/10871) 문제를 통해 표현의 의미를 한 번 이해해보겠습니다. 
</br>

- 실제 개발을 오래 하셨던 분들은 코드를 아주 정교하게 짜시는 경우가 더러 있습니다.
- 대략 왼쪽 코드와 같은 방식인데, 아주 깔끔하죠.
- 그런데 코딩테스트에서는 내가 헷갈리지 않는 범위 안에서 어떻게든 타이핑을 아끼는게 최고입니다. 
- 그래서 저는 오른쪽 위와 같은 코드를 짤것입니다.
- 오른쪽 위와 같이 코드를 짠다면 현업을 하는 상황이라면 코드리뷰에서 대차게 까일 것입니다.
- "아니 cin/cout만 쓰면서 온갖 헤더를 다 include 할거야?", "sync_with_studio는 bool 자료형을 인자로 받는데 왜 0을 넣어?", "왜 전역에 다 때려박아?", "배열 크기는 왜 5를 더 크게 받았어?" 등등...
- 그런데 코딩 테스트의 목표는 남이 알아볼 수 있는 클린 코드를 작성하는게 아닙니다.
- 어떻게든 제한 시간 안에 정답을 받아야 하빈다. 
- 그리고 사실 문제 상황을 본다면 배열 자체가 필요없기 때문에, 저는 더 줄여서 오른쪽 아래와 같이 짤 것입니다. 

<img src="https://user-images.githubusercontent.com/83942393/135805625-663e83e4-6701-4df6-a52e-2f382d724891.png" width="80%"></img></br>
<img src="https://user-images.githubusercontent.com/83942393/135805645-03410f38-b42f-4e1c-ae2f-0494d8bcc614.png" width="80%"></img></br>

- 갈 길이 까마득하게 멀지만, 그래도 조금씩 하다보면 분명 발전이 있을 거니까 당장 지금부터 백준 그룹 내의 문제들을 계속 풀어보세요.
- 풀다가 모르는 게 있으면, 풀이를 검색하셔서 풀이를 적극적으로 찾아보는 것을 추천합니다.
- 적어도 알고리즘 공부에서만큼은 어떻게 푸는 건지 잘 모르겠다고 할 때 풀이를 찾아보는 게 나쁘다고 생각하지 않습니다.
- 한 30분 정도 고민했는데도 전혀 실마리가 잡히지 않으면 네이버나 구글 같은 곳에 문제 번호로 검색해서 다른 사람의 코드를 보고 배워가시면 됩니다. 


