## C강. 백트래킹
<img src="https://user-images.githubusercontent.com/83942393/139836492-726703b1-6b00-44d3-b26c-bcd231c9c274.png" width="60%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/139836510-78e7c956-49d9-49d7-bf17-93972bfd1b4b.png" width="60%"></img></br>
- 백트래킹의 정의를 읊어보자면 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘입니다. 
- 정의를 봐도 그다지 느낌이 없을텐데 백트래킹이란 걸 전혀 몰랐더라도 분명 이 알고리즘을 써서 실생활의 문제를 해결해본 경험이 분명 있을 것입니다.
</br>

- 왼쪽 위부터 차례대로 프린세스 메이커, 미연시, 역전 재판, 검은방, 회색도시, 문명입니다.
- 이렇게 게임에서 선택지가 막 나누어질 때 저희는 뭔가 하나를 정해서 가야합니다.
- 검은방 스샷을 가지고 얘기를 이어가보면, 저 3가지 선택지 중에서 첫 번째를 선택했더니 게임오버가 떴다고 해보겠습니다. 
- 그러면 되돌아와서 두 번쨰를 선택해볼꺼고, 두 번쨰도 이상하면 세 번쨰 것을 선택해보고 결론적으로 모든 경우를 다 훝어보게 될 것입니다. 
</br>

- 즉, 현재 상태에서 가능한 모든 선택지를 다 플레이해보는 방법이 바로 백트랙킹입니다.
- (추가로, 완전탐색과 다른 점은 백트래킹은 현재 상황에서 가능한 선택지만을 가지치기하여 훝어보는 알고리즘이고, 완전탐색은 모든 선택지를 훝어보는 알고리즘이다.)
</br>

<img src="https://user-images.githubusercontent.com/83942393/139837240-3c939a58-26f7-485a-afef-81a782bc32fb.png" width="60%"></img></br>
- 백트래킹의 쓰임새를 하나 더 설명해보자면 백트래킹이 요새 핫한 분야와도 조금 닿아있습니다.
- 바로 알파고인데요, 오목으로 예를 들어 백트래킹의 쓰임새를 설명드리겠습니다.
- 저희는 파랑 돌이고 상대는 직전에 D5를 뒀습니다.
- 이 상황에서 저는 어디에 둘지 정해야 하는데 C5 D5 E5로 대놓고 세로로 3개가 완성된게 있으니 저걸 막아야 합니다.
- 그러면 B5나 F5 중 하나를 선택해야 함은 자명한데, 둘 중에 어딜 두면 좋을지 고민해봅시다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139837466-fbb08a7e-1726-4b83-b90d-8929bdb34d99.png" width="60%"></img></br>
- 먼저 B5에 뒀다고 가정을 해보면 상대는 물론 어디에나 두어도 상관 없지만 상대가 F5에 착수를 한다면 굉장히 곤란해질 것입니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/139837534-5e81b38f-c1a2-448a-a44e-654f75272823.png" width="60%"></img></br>
- 상대의 4-3이 완성되었기 때문에 내가 G5에 둔다 한들 상대가 F6을 두게 될거고,
</br>

<img src="https://user-images.githubusercontent.com/83942393/139837644-a4ea2fac-cc1e-4852-8c1a-716e1852cd03.png" width="60%"></img></br>
- 내가 F6을 두면 상대는 그냥 G5를 둬서 바로 오목을 완성할 것입니다.
- 이렇게 내가 B5에 뒀을 때 생기는 상황을 쭉 따라올라가 확인한 결과 B5에 두면 진다는 것을 알게 됐습니다.
- 그 다음으로 F5에 착수한 뒤의 상황을 확인해보겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139837929-7c54f8cb-87dc-4e39-b3f6-4f9ec3ed83ab.png" width="60%"></img></br>
- 이 상황에서 상대는 B5나 E6이나 C4나 G8에 두면서 공격을 이어나가려고 할 것 같습니다.
- 그럼 우리는 그 각각의 수들에 대해 다시 나의 대응 수를 정해보는 식으로 계산을 이어갈 수 있겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139838391-f6da42b8-4fe6-4797-8378-86c5af1f42ff.png" width="60%"></img></br>
- 지금 이 방식이 일종의 백트래킹인거고 용어를 몰랐다 뿐이지 우리는 지금까지 게임을 할 때, 아니면 오목을 둘 떄 백트래킹을 자연스럽게 이용했던 것입니다.
- 참고로 이렇게 생긴 트리를 상태공간트리라고 하나 한번 듣고 그냥 잊어버리셔도 상관없을 것 같습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/139838511-38f116ef-054b-41a7-90eb-1349b61bf55f.png" width="60%"></img></br>
- 이정도면 워밍업은 적절하게 된 것 같은데, 대충 개념은 이해했다고 치더라도 막상 백트래킹 문제를 풀려고 하면 꽤 많은 애로사항이 있습니다. 
- 백트래킹은 상당한 구현력을 필요로 하고 실수하기도 쉽습니다.
- 또 앞 단원의 문제를 풀다가 느꼈을테지만 재귀의 특성상 틀리더라도 실수한 부분을 찾기가 정말 힘듭니다.
- 그래서 굉장히 많은 시간을 할애해 개념을 익히고 연습을 해야하고, 그렇지 않으면 풀이는 대충 알겠는데 그 풀이를 코드로 옮겨내지 못해서 문제를 틀릴 확률이 큽니다.
- 그래도 한편으로는 그렇게 응용할 수 있는 건덕지가 많지는 않기 때문에 예제들을 꼼꼼히 풀고 BFS를 배울 때와 비슷하게 기본적인 코드의 형태를 익혀두면 그럭저럭 할만한 것입니다. 
</br>

- 백트래킹을 익힐 때 BOJ의 N과 M 시리즈가 아주 적절한데 총 12문제 중에서 1개만 같이 풀어보겠습니다.
- 비어있는 리스트에서 시작해 수를 하나씩 추가하면서 길이가 M인 수열이 완성되면 출력하는 방식으로 구현할 수 있고, 이해를 돕기 위해 상태공간트리로 나타내겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139839706-af7c518e-9fb8-4d1a-a127-5ad79af0d1a2.png" width="60%"></img></br>
- 처음에는 빈 리스트로 시작합니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139839738-6195fc5a-a0c0-400f-b383-cda6dffceff6.png" width="60%"></img></br>
- 여기서 첫 번째 원소를 1으로 둡니다.
</br>

- 별의 의미가 조금 불명확할 수 있는데, 백트래킹은 상태를 넘나듭니다. 
- 상태를 넘나든다는게 빈 리스트인 상태였다가 첫 번째 원소로 1이 쓰인 상태로 넘어가는 것과 같은 상황을 말합니다. 
- 이 때 별은 현재 어떤 상태에 위치해있는지를 나타냅니다. 
- 잘 와닿지 않더라도 일단 한번 보겠습니다. 
- 지금 첫 번째 원소로 1이 쓰였으니 두 번째 원소로는 2, 3, 4가 가능합니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139839832-8c4cd59c-92cc-478c-a807-81f43064cce4.png" width="60%"></img></br>
- 먼저 2를 써보겠습니다. 
- 지금 1, 2가 채워진 상태까지 왔습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139839860-81f2ddcb-6544-48f3-86f9-e75beeff9716.png" width="60%"></img></br>
- 마지막 원소로는 일단 3을 넣을겠습니다. 
- 이렇게 모든 칸이 찼으면 수열을 완성한거니 출력하고 여기서는 이제 이전 상태로 되돌아가야 합니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139839900-c66eeafd-8c62-4f67-9f41-27245e2ed1c3.png" width="60%"></img></br>
- 되돌아가기 위해 마지막 원소를 빼고 다시 마지막 원소를 채워야하는데 지금 여긴 3 혹은 4가 가능한 상황입니다. 
- 그리고 3은 이미 확인했으니 4를 넣은 상태로 이동하면 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139839942-16f8c39d-09a8-4e4b-a61d-d560a09780a8.png" width="60%"></img></br>
- 이렇게 해서 1 2 4도 얻어냈습니다. 
- 수열을 출력했으니 돌아갑니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139839983-ed055424-be87-4c04-83e6-924795dd9250.png" width="60%"></img></br>
- 지금 여기서 무엇을 하는지가 문제인데 마지막 칸으로 올 수 있는 3과 4를 다 넣어봤습니다. 
- 그러니 지금 할 수 있는건 다 한 상태이고 여기서도 되돌아가면 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139840020-fedaf839-ea60-49fd-bd03-23922a5bb733.png" width="60%"></img></br>
- 이 다음 무엇을 하면 좋을지는 대충 감이 올 것 같습니다. 
- 두 번째 칸에 3을 넣은 상태로 가면 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139840069-b84bcb8e-d28a-4e9f-b02b-90699d337181.png" width="60%"></img></br>
- 현재 아직 사용하지 않은 수는 2와 4이니 먼저 마지막 칸에 2를 넣어보고 되돌아와 4를 넣으면 되겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139840099-9b7336f7-afea-423b-8f6f-425da2f5b5f7.png" width="60%"></img></br>
- 공간이 좁은 관계로 여기까지만 설명을 하겠습니다. 
- 보면 동작 흐름은 크게 어렵지 않게 이해가 갈 것 같습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139840235-696ff279-33cf-4a90-95cd-b4c861f61a86.png" width="100%"></img></br>
- 보면 재귀적으로 구현이 된 것을 볼 수 있는데 지금 이 구조가 백트래킹의 전형적인 구조여서 잘 익혀둘 필요가 있습니다. 
</br>

- 먼저 전역 변수들의 쓰임새들을 짚고 가자면, n과 m은 입력으로 주어진 그 값이고 arr은 수열을 담을 배열, isused는 특정 수가 쓰였는지를 true 혹은 false로 나타내는 배열입니다.
- 앞에서 상태라는 용어를 계속 사용했는데, n=4, m=3에서 현재 상태가 3, 2가 채워진 상태라고 한다면 arr[0]=3, arr[1]=2이고 1과 4는 아직 쓰이지 않았는데 2와 3은 쓰였으므로 isused[1] = false, isused[2] = true, isused[3] = true, isused[4] = false 입니다.
</br>

- 그 다음으로 재귀함수인데, 이 함수 func(k)는 현재 k개까지 수를 택한 상황에서 arr[k]를 정하는 함수입니다.
- 맨 처음에는 수를 하나도 택하지 않았으니 func(0)를 호출할거고 func(0)은 arr[0]을 정한 후에 func(1)을 호출합니다.
</br>

- func 이 재귀 함수이니 당연히 base condition 이 필요하고, k=m이 되었을 때 m개를 모두 택했으니 수열을 출력한 후 함수를 종료하면 된다는 것을 알 수 있습니다.
- 만약 k가 m이 아니라면 if문을 건너뛰어 15번째 줄로 넘어오고 여기서는 1부터 n까지 수를 차례로 확인하며 아직 쓰이지 않은 수를 찾아냅니다.
</br>

- isused[i]가 false 일 때 if문이 참이 되고, arr[k]=i, isused[i] = true 로 만든 후 func(k+1)을 호출합니다.
- 그 후 20번째 줄에 도착했다는 건 arr[k] = i 로 둔 상태에서 func(k+1)에 들어갔다가 모든 과정을 끝냈다는 얘기이니 isused[i]=false로 되돌려 수 i가 사용되지 않음을 명시합니다.
- 단 현재 값이 i인 arr[k]는 굳이 0과 같은 값으로 변경할 필요가 없는데 어차피 자연스럽게 다른 값으로 덮힐 예정이라 그런 것입니다. 
</br>

- 제 생각에 15-22번째 줄이 백트래킹의 핵심이면서 한편으로는 재귀에 어느 정도 익숙하다고 해도 정말 헷갈릴 파트입니다.
- 다음 슬라이드에서 n = 4, m = 3 일 때를 예시로 들어 다시 설명을 드리긴 하겠지만 이해가 안간다면 함수의 중간 중간 arr, isused, k를 출력한다던가 하는 방식으로 동작 원리를 세밀하게 들여다보시고, 그래도 헷갈리는게 있다면 100% 이해하려고 하기 보다는 이 기본 틀을 바탕으로 n과 m 시리즈들을 풀어보면 자연스럽게 체화될 수도 있습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842185-a20d9758-e1e6-4b11-952b-acfa2b080fbb.png" width="60%"></img></br>
- N = 4, M = 3일 때 func(0)을 호출한다면 실제로 어떤 일이 발생하는지 호출 과정을 따라가면서 이해해보겠습니다. 
- 일단 arr와 isused는 전역 변수이니까 모두 0과 false로 초기화가 되어있습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842219-75a9d536-c726-47cc-940f-7352838ce77c.png" width="60%"></img></br>
- 이 상황에서 func(0)이 호출되고 func(0) 내에서 i = 1일 때를 생각해보면 isused[1]이 false이기 때문에 if문 안으로 들어와 arr[0] = 1로 바뀌고 isused[1] = true로 바뀐 후 func(1)이 호출됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842279-5b981904-1146-475d-ba96-9254e22a7282.png" width="60%"></img></br>
- func(1)에서 i = 1일 때를 생각해보면 isused[1] = true이기 때문에 넘어갑니다. 
- i = 2일 때에는 if문 안으로 들어갈거고 arr[1] = 2로, isused[2] = true로 바뀐 후 func(2)가 호출됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842316-95febd96-d19f-413a-af96-cd0e1ec65de4.png" width="60%"></img></br>
- 이 다음으로는 isused[1], isused[2]가 true이므로 i = 1, 2일 때 넘어가고 i = 3일 때는 가능합니다. 
- arr[2] = 3으로, isused[3] = true로 바뀐 후 func(3)이 호출됩니다. 
- func(3)에서는 base condition에 도달했으니 지금 arr에 써져있는 대로 1, 2, 3을 출력합니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842363-64d94375-a9cd-46dd-9e5c-0a87f80c1235.png" width="60%"></img></br>
- 이후 return을 만나서 돌아갑니다. 
- 지금 func(3)을 들어갔다 왔으니 13번째 줄을 실행할 차례이고 그에 따라 isused[3] = false가 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842496-35e0b3af-1f00-44ca-b1bf-3d7b55f45fa6.png" width="60%"></img></br>
- 그 다음으로 i = 4인 상황이라 arr[2] = 4, isused[4] = true가 된 후 func(3)이 호출됩니다. 
</br>

- 여기까지 같이 살펴봤는데 i는 각 상태들이 따로 가지고 있고 arr와 isused는 공통으로 쓰니 조금 헷갈릴 수 있지만 차분하게 상황을 따져보면 5페이지에서 본 상황 그대로입니다. 
- 강의 안에서는 N과 M (1)만 다루지만 나머지 N과 M 시리즈들도 다 풀어보는 것을 추천합니다. 
- 시리즈를 다 해보고 나면 백트래킹을 모를래야 모를 수 없게 될 것입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842614-10dace2b-7491-4952-9294-68238ed3206d.png" width="60%"></img></br>
- 두 번째 문제는 N-Queen 문제입니다(BOJ 9663번: N-Queen). 
- 이 문제는 N × N 체스판에 퀸 N개를 서로 공격하지 못하는 위치에 놓는 경우의 수를 구하는 문제입니다. 
- 퀸은 체스판 위에서 상하좌우와 대각선으로 공격할 수 있는 기물이고 N = 4일 때를 예로 들면 슬라이드 상의 저 2가지 배치가 가능한 배치입니다. 
- 오른쪽의 배치는 빨간색으로 칠한 퀸 2개가 서로를 대각선으로 공격할 수 있는 위치에 있기 때문에 불가능한 배치입니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842720-a9a573fd-3ad5-48d4-bdb6-26827fd9c683.png" width="60%"></img></br>
- 그럼 백트래킹을 어떤 식으로 구현하냐고 했을 때 절차가 그렇게 어렵지는 않습니다. 
- 이 문제를 직접 손으로 계산해보라고 한다면 제가 봤을 때 아마 열에 아홉은 각 행에 대해 퀸을 한 개씩 놓으면서 밑으로 내려오는 방식으로 구현을 할 것입니다. 
- 다들 각 행에 퀸이 딱 1개씩 있어야 한다는 사실을 자연스럽게 받아들이고 있기 때문입니다. 
- 그래서 N = 4일 때를 같이 해본다고 생각하면서 상태공간트리를 만들어보겠습니다.
</br>

- A행에서 퀸을 어디에 둘지 정해야하는데 먼저 A1에 두겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842782-5f04977d-9f71-49c9-a651-129880adf52c.png" width="60%"></img></br>
- 이제 B행에 퀸을 둘 차례인데 A1에 퀸을 뒀으니 자연스럽게 B1과 B2에는 퀸을 둘 수 없고 가능한 곳은 B3 혹은 B4입니다. 
- B3에 퀸을 두겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842849-fa8b0b77-0839-47d3-89c1-9ad90e3b0eb0.png" width="60%"></img></br>
- B3에 퀸을 두고 나면 C행에는 퀸을 둘 수 있는 곳이 아예 없습니다. 
- 그래서 더 내려갈 수 없고 B3에 놓은 퀸을 무르면서 올라가야 합니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842880-02d0ddef-89f6-4a8a-8e00-d6a9b7359702.png" width="60%"></img></br>
- 그 다음으로는 B4에 퀸을 놓아보겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842923-6949c38b-263b-4ddc-ad09-0a0aeefef59b.png" width="60%"></img></br>
- B4에 놓으면 C행에서 C2만 유일하게 퀸을 둘 수 있는 곳이니 C2에 퀸을 두겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842951-4a41589c-eb9d-4813-a67d-341e97d9e6e2.png" width="60%"></img></br>
- 두고 났더니 D행에 퀸을 둘 수 있는 곳이 없고 되돌아가야합니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139842968-c9ffbfdc-ce41-419f-bb4e-87fa599cdbe6.png" width="60%"></img></br>
- 정신을 차려보니 꼭대기까지 도달했습니다. 
- A1에 퀸을 놓음으로서 생기는 모든 경우를 다 따졌고 이제는 A2에 퀸을 놓아볼 차례입니다.
</br>

- 이후의 진행은 앞에서 본 것과 똑같으니 굳이 또 보여드릴 필요는 없을 것 같아 최종적인 상태공간트리를 한 번 확인해보시고 더 이상 진행하지는 않겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139843017-d63fc096-44d8-4eb0-b6d4-da7623cf897f.png" width="60%"></img></br>
- D행에 퀸을 놓았다면 퀸을 4개 놓는데 성공했다는 의미이니 상태공간트리를 통해 N = 4일 때의 답은 2임을 알 수 있습니다. 그리고 이제 우리는 이걸 코드로 구현해볼 것입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139843062-68a1c1bc-ad2a-44c4-86ac-881ee2486d17.png" width="100%"></img></br>
- 일단 함수의 기본 틀은 이렇게 생겼습니다. 
- func(0)을 호출해 0번째 행에 퀸을 배치하고 func(0)은 func(1)을 호출하고, 이렇게 진행하다가 func(n)이 호출되면 퀸 n개를 놓는데 성공했다는 의미이니 cnt를 1 증가시킵니다. 
- 여기까지는 좋은데 이 문제에서 가장 어려운 부분은 특정 좌표에 퀸을 둘 수 있는지를 어떻게 판단할 것인가 하는 문제입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139843158-e8e4b34a-60b8-452e-88dd-7cb95b7040e0.png" width="60%"></img></br>
- 지금 이렇게 퀸이 (0, 0)과 (1, 3)에 있을 때 (2, 0), (2, 2), (2, 3)은 퀸을 둘 수 없지만 (2, 1)에는 퀸을 둘 수 있다는 사실을 우리는 눈으로 보고 쉽게 알아낼 수 있습니다. 
- 하지만 이걸 컴퓨터가 계산할 수 있게 만들어야 하는데 어떻게 해야할까요? 
</br>

- 처음 이 문제를 처음 접했으면 모르는게 당연한거라 너무 마음을 조급하게 먹지는 마시고 한 단계씩 진행하겠습니다. 
- 우리는 각 행에 퀸을 한개씩만 놓으니까 한 행에 퀸이 2개인지는 생각할 필요가 없는데 열과 대각선에 대해서는 생각을 해야 합니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139851190-293b3697-1db2-4d88-b081-9aadd9a962d5.png" width="60%"></img></br>
- 먼저 (0, 1)과 (2, 1)이 같은 열에 있다는걸 어떻게 확인할 수 있는지 고민해봅시다. 
- 이건 아주 간단한데 그냥 y좌표가 일치하는지를 확인하면 끝입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139843309-e9df993e-666f-415a-bc3f-3324bbae68ac.png" width="60%"></img></br>
- 그 다음으로 볼건 좌측 하단과 우측 상단을 잇는 대각선인데 (3, 0)과 (1, 2)가 같은 대각선에 있음을 어떻게 알 수 있을까요?
- 이건 사실 살짝의 수학적 관찰을 필요로 하는데 좌표들의 x+y가 같으면 좌표들은 같은 좌측 하단과 우측 상단을 잇는 대각선에 위치해있습니다. 
- 좌측 하단과 우측 상단을 잇는 대각선이란게 x가 1 증가하면 y가 1 감소하는 대각선이니 크게 어렵지는 않게 이해할 수 있을 것 같습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139843659-c895c2a8-4874-40b8-854e-55fbb09d67a0.png" width="60%"></img></br>
- 마지막으로 좌측 상단과 우측 하단을 잇는 대각선에 대해서는 좌표들의 x-y가 같은지를 보면 됩니다. 
- 예를 들어 (1, 1)과 (3, 3)은 x-y가 0으로 동일하니 두 좌표는 같은 좌측 상단과 우측 하단을 잇는 대각선에 위치함을 알 수 있습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139843813-b3755045-3eb9-4f78-9adb-0e12ea742f4d.png" width="60%"></img></br>
- 여기까지 했으면 이런 방법을 머릿속에서 떠올릴 수 있을 것 같습니다. 
- 지금까지 놓은 놓은 퀸의 목록을 외부 변수로 가지고 있다가 func 함수 안에서 퀸을 놓을 때 각 퀸과 대각선 혹은 열에서 만나는 것이 있는지를 확인하는 것입니다. 
- 이 방법이 이해가 가나요? 이 방식대로 구현을 하면 통과될 수 있고 나쁘지 않은 방법이지만 사실 더 좋은 방법이 있어서 설명을 조금 더 드리겠습니다. 
</br>

- 이전 챕터에서 다룬 N과 M (1) 문제에서 현재 상태가 {1, 4, 3}일 때 그 다음 수로 2를 쓸 수 있는지 어떻게 판단했는지 기억을 되새겨봅시다. 
- 현재까지 쓰인 원소들 중에 2가 있는지를 1, 4, 3를 다 순회하면서 확인했나요? 
- 그렇지 않습니다. 그게 아니고 그냥 isused[2]가 true인지만 확인했습니다. 
</br>

- isused 없이는 지금 2를 쓸 수 있는지 최대 M-1개의 수를 확인해야 하기에 그 과정에서 O(M)이 필요한데 isused를 쓰면 O(1)에 바로 2를 쓸 수 있는지 알 수 있다는 장점이 있습니다. 
- 지금 이 문제에서도 놓은 모든 퀸에 대해 대각선 혹은 열에서 만나는 것이 있는지를 확인하려고 한다면 그 과정에서 O(N)이 추가로 필요하게 되는데 각 대각선과 열의 점유 상태를 나타낼 isused 변수를 두면 시간을 절약할 수 있게 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139844031-5e058f58-efee-48eb-9ea0-0c8f83965d37.png" width="60%"></img></br>
- isused1은 열에 대응되는 값으로, (x, y)에 퀸이 있으면 isused1[y]를 true로 만들면 됩니다.
- (그러면 y 열은 isused1[true]가 되어 모두 사용 불가능)
</br>

<img src="https://user-images.githubusercontent.com/83942393/139844088-3b420b22-f994-4607-ace7-f15cfe9ef216.png" width="60%"></img></br>
- 두 번째는 좌측 하단과 우측 상단을 연결하는 대각선이고 (x, y)에 퀸이 있으면 isused2[x+y]를 true로 만들면 됩니다.
- (그러면 (x, y)의 좌측 하단 우측 상단을 연결하는 대각선 위치에 있는 좌표들은 모두 isused2[true] 가 되어 사용 불가능)
</br>

<img src="https://user-images.githubusercontent.com/83942393/139844306-883831f6-f01d-4eee-84ce-ba21d71b60d2.png" width="60%"></img></br>
- 마지막은 좌측 상단과 우측 하단을 연결하는 대각선이고 (x, y)에 퀸이 있으면 isused3[x-y+n-1]을 true로 만들면 됩니다.
- n-1이 붙어서 좀 예쁘지 않게 생겼지만 인덱스를 음수로 보내지 않게 하기 위해서는 어쩔 수 없었습니다.
- (마찬가지로, (x, y)의 좌측 상단과 우측 하단을 연결하는 대각선 위치에 있는 좌표들은 모두 isused3[true]가 되어 사용 불가능)
- (x-y의 최소값은 n이 4라면 0-3 = -3 이므로 n-1인 3을 더해주면 인덱스를 0부터 쓸 수 있다.)
</br>

- 이제 N과 M (1) 문제에서 한 것과 비슷하게 진행을 하면 됩니다. 
- func(cur)에서는 (cur, 0), (cur, 1), …, (cur, n-1)에 퀸을 둘 수 있는지 확인합니다. 
- 둘 수 있는지는 isused1, isused2, isused3을 보면 알 수 있습니다. 
- 만약 (cur, i)에 퀸을 둘 수 있다면 isused1[i], isused2[cur+i], isused[cur-i+n-1]을 true로 변경한 후 func(cur+1)을 호출합니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/139845744-1c8d9146-d0a4-4bdc-b16e-b750d09a0dd4.png" width="100%"></img></br>
- 코드의 흐름에서 크게 어려울건 없어보이고 20, 21, 22번째 줄의 처리와 같이 함수를 들어갔다가 나올 때 isused 값들을 false로 만들어줘야 하는걸 꼭 까먹으면 안됩니다.  
</br>

- 그리고 이 문제에서 우리는 시간복잡도를 제대로 파악하기가 많이 힘듭니다. 열만 가지고 생각을 해보면 O(N!)이니 N = 14일 때 조금 애매한데 실제로 구현을 해서 돌려보면 꽤 빠르게 돕니다. 
</br>

- A1에 퀸을 놓으면 바로 B1, B2에 퀸을 놓는 경우는 해볼 필요가 없어지는 것과 같은 상황을 백트래킹에서 가지치기라고 부르는데 가지치기가 빈번하면 백트래킹의 시간복잡도를 가늠하기가 많이 힘듭니다. 
- 그렇기 때문에 문제를 보고 시간복잡도가 가늠이 잘 안가는데 N이 많이 작아 백트래킹으로 푸는 문제일 것 같다는 생각이 들면 직접 구현한 뒤 가장 시간이 오래 걸릴만한 케이스를 직접 돌려봐서 시간 초과가 나는지 안나는지를 보면 됩니다. 
- 이 문제라면 N = 14를 넣어보는 것입니다. 
- 만약 시간이 애매하면 최대한 최적화할 수 있는 것들을 찾아서 고치고 제출을 하면 됩니다. 
- 시간을 로컬에서 측정할 때에는 반드시 Release 모드로 실행을 해야 하고 보통은 서버가 로컬보다 빠르다는 점도 기억하시면 좋습니다. 
- Release 모드가 무엇인지는 구글에 한 번 검색해보세요.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139845994-153989be-983a-43a0-8ecb-554a250fd8cd.png" width="60%"></img></br>
- 세 번째 문제도 괜찮은걸로 준비를 해봤습니다. 문제를 한 번 보고 오시면 됩니다(BOJ 1182번: 부분수열의 합). 
</br>

- 문제를 풀기 전에 선행적인 지식으로 알고 있으면 좋은게 있는데, 원소가 n개인 집합에서 부분집합의 갯수는 2^n입니다. 
- 각 원소는 포함되거나 포함되지 않거나 이 2가지의 선택권을 가지고 원소는 총 n개이니 2가 n번 곱해져 2^n이 됩니다. 
- 문제에서의 표현은 수열과 부분수열이지만 부분집합을 고르는 것과 동일한 상황이니 공집합은 빼고 2^n -1 개의 모든 부분수열에 대해 합이 S와 일치하는지를 확인하면 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846265-fa851ef3-c0c9-4d8a-9153-105064ca4f27.png" width="60%"></img></br>
- 수열이 -2, 5, 3일 때의 상태공간트리를 그리겠습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846431-6646aaa7-cb23-4c05-b119-9e84c4afec09.png" width="60%"></img></br>
- 원 안의 값은 현재 내가 택한 수열의 전체 합을 의미합니다. 
- 각 상태는 두 갈래로 분기하는데 왼쪽은 현재 보는 수를 수열에 추가하지 않은 경우이고 오른쪽은 수열에 추가한 경우입니다. 
- 먼저 -2를 수열에 추가하지 않았다고 하겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846515-4ce3a1e2-eb7e-4e98-885b-a30925454f36.png" width="60%"></img></br>
- 그러면 합은 여전히 0이 됩니다. 
- 그 다음은 5를 더할지 말지 정하는 단계이고 또 추가하지 않습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846595-a5a32c7a-8a6c-4e11-9f08-28c0d06a8d25.png" width="60%"></img></br>
- 이렇게 우리는 3개의 수를 더할지말지 다 정했고 합 0을 얻었습니다. 
- 3개의 수를 다 더하지 않았으니 지금의 상태는 공집합에 대응됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846622-c05d7fc2-b2c6-41ee-b29d-a9c535281e3f.png" width="60%"></img></br>
- 거슬러 올라가면 다시 3의 행방을 고를 순간이고 이번에는 수열에 추가해보겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846677-19d2ea1c-8004-4ab0-b9e9-5203feeff98a.png" width="60%"></img></br>
- 이제 합은 3이 됐고 이 합은 {3}이라는 집합으로부터 얻어낸 것입니다. 
- 할거 다 했으니 돌아가고, 또 돌아갑니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846735-e3225dff-6326-4a41-b4e5-24e5a89b29e0.png" width="60%"></img></br>
- 이번에는 5의 행방을 골라야 하고 5를 수열에 추가하겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846767-76974341-d0bb-45f3-8b79-4b4b2be072bd.png" width="60%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846819-4d3d4f7b-0727-4cae-9001-8a06d16ab296.png" width="60%"></img></br>
- 이 상황에서 먼저 3를 추가하지 않아 {5}의 합을 보고
</br>

<img src="https://user-images.githubusercontent.com/83942393/139846860-7f6fe19f-c799-4cc0-8311-e916917fa4c4.png" width="60%"></img></br>
- 다음으로 3을 추가해 {3, 5}의 합을 봤습니다.
- 이후 과정은 생략하겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139847268-0cc55de8-31db-4d8f-90ba-63651cc79c66.png" width="60%"></img></br>
- 이렇게 매 순간 수를 더할지 더하지 않을지 선택하는 방법으로 모든 부분 수열의 합을 뽑아낼 수 있습니다. 
- 이제 이 값을 S와 비교해주면 끝입니다. 다음 슬라이드에서 코드를 같이 보겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139847316-17b30e47-7e29-45c6-a306-ae39ac50165e.png" width="100%"></img></br>
- 실제 구현을 할 때에는 함수의 인자로 현재까지의 합을 가져가게 했습니다. 
- 그리고 문제에서 크기가 양수인 부분수열만 센다고 했으니 공집합은 제외를 해줘야 하는데 s가 0이 아닐 때에는 상관이 없고 s가 0일 때에는 cnt에서 1을 빼줘야 합니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139847432-42dc9039-11f3-4007-8e1d-566facdc388c.png" width="100%"></img></br>
- 얼추 백트래킹에서 핵심적인 문제들은 다 다루었고 이번 챕터에서 소개할건 C++ 한정 아주 사기성이 짙은, 마치 테란의 스파이더 마인과 같은 next_permutation 함수입니다. 
- 나중에 코딩테스트 문제들을 풀다보면 순열과 조합을 가지고 코딩 노가다가 빡세게 들어가는 것들을 보게 됩니다. 
- 당장 N과 M 시리즈도 그런 유형입니다. 
- 이런 문제들을 백트래킹으로 해결할 수 있지만 아무래도 백트래킹은 실수할 수 있는 여지가 있고 코드도 길어집니다. 
- 그런데 이 next_permutation 함수만 있다면 아주 깔끔하게 순열과 조합을 해결할 수 있습니다. 
</br>

- 일단 레퍼런스는 알아서 참고하시고 바로 사용 예시를 보면 1 2 3을 가지고 만들 수 있는 모든 순열을 왼쪽과 같이 쉽게 구할 수 있습니다. 
- next_permutation은 현재의 수열을 사전 순으로 생각했을 때의 다음 수열로 만들고 true를 반환하는 함수입니다. 
- 현재가 1 2 3이면 next_permutation을 실행한 후 1 3 2가 되고, 1 3 2에서 next_permutation을 실행하면 2 1 3이 됩니다. 
- 만약 현재의 수열이 사전 순으로 생각했을 때 제일 마지막이어서 다음 수열이 존재하지 않는다면 false를 반환합니다. 
- 그렇기 때문에 지금처럼 do-while 문으로 작성하면 코드가 깔끔하게 떨어집니다. 
</br>

- 만약 중복된 수가 있다고 해도 사전 순의 결과를 잘 돌려줍니다. 
- 예를 들어 1 1 2에서 시작했다면 1 2 1, 2 1 1로 바뀌게 됩니다. 
- 함수의 이름에서 볼 수 있듯 이 함수를 가지고 순열을 잘 처리할 수 있는데 만약 조합이 필요하다면 어떻게 해야할지 고민해봅시다. 
- 예를 들어 1 2 3 4에서 수 2개를 순서 없이 뽑는 모든 경우를 출력하는 문제와 같은 상황입니다. 
</br>

- 그럴 때에도 이 함수를 이용하면 되는데 오른쪽의 코드를 확인해보겠습니다. 
- 바로 0과 1을 이용해 next_permutation을 돌리는 방법으로 해결하면 됩니다.
- 4개에서 2개를 뽑는게 아니라 5개에서 3개를 뽑는 문제라면 배열 a를 {0, 0, 0, 1, 1}로 두면 되겠습니다. 
</br>

- 이와 같이 next_permutation을 쓰면 순열과 조합이 필요할 때 아주 정확하고 또 타이핑을 아끼면서 구현을 해낼 수 있습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/139847835-3fca9405-4543-4d4e-bf1d-e6d78f496010.png" width="60%"></img></br>
- 이번 강의도 잘 마무리됐습니다. 
- 재귀와 백트래킹은 많이 힘든 파트이지만 문제들을 많이 풀다보면 함수의 구성이 정형화되고 머릿속에 마치 공식처럼 자리잡아서 백트래킹 문제가 두렵지 않게 됩니다.
- N과 M 시리즈를 포함한 연습문제들을 꼭 백트래킹으로 풀어보시고 N과 M 시리즈의 문제 중에서 1, 2, 5, 6번은 next_permutation을 써서도 다시 풀어보셔야 합니다. 
- 1, 2, 5, 6번과 같은 상황에서는 next_permutation을 통해 구현을 효율적으로 하도록 합시다.
 </br>
 
- 단, N과 M 3, 4, 7, 8 등과 같이 같은 수를 여러 번 쓸 수 있는 상황에서는 next_permutation을 사용하기가 어렵습니다.
</br>

- 다음 시간은 어찌됐든 재귀가 끝났기 때문에 최근 강의들보다는 훨씬 수월합니다. 고생 많으셨습니다.
</br>
