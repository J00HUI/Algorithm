## 1강. 기초 코드 작성 요령 1
### Contents
1. 시간, 공간 복잡도
2. 정수 자료형
3. 실수 자료형

### 1. 시간, 공간 복잡도
<img src="https://user-images.githubusercontent.com/83942393/135589325-44423484-e861-46ac-b1da-adcf0dc8ab75.png" width="80%"></img></br>
- 시간 제한이 1초라고 되어 있는데, 컴퓨터는 1초에 대략 3-5억 개 정도의 연산을 처리할 수 있습니다. (단, 연산이 비트 AND, OR, 비교, 덧셈과 같은 단순한 연산인지, 아니면 나눗셈, 곱셈, 대입, 함수 호출과 같은 복잡한 연산인지에 따라 횟수에 조금 차이가 날 수 있어, 3-5억이라는 값은 어림 잡은 값이라는 것을 주의해야 합니다.)
- 이 코드는 연산을 몇 번 할지 생각해봅시다.
- 05번째 줄에서 두 변수를 입력 받을 때 두 번, 06번째 줄에서 두 수를 더하고 출력할 때 연산이 필요하니 대충 3, 4번의 연산이 필요합니다. 
- 그러므로, 1초 내로는 충분히 프로그램이 모든 명령을 수행한 후 종료되고, 엄밀히 말하면 0.000001초도 안 걸릴 것입니다. 
- 그러면 이제 시간 제한이 우리에게 어떤걸 알려주는 지 조금 감이 올 것입니다.
- 예를 들어, 시간 제한이 1초라고 하면, 이건 "당신의 프로그램은 3-5억 번의 연산 안에 답을 내고 종료되어야 한다"라는 것을 알려주는 것입니다.

<img src="https://user-images.githubusercontent.com/83942393/135590277-e546b6d0-b4ce-4fe0-8786-ef76b95d35ef.png" width="80%"></img></br>
- 그런데, 3-5억 번의 연산이 필요하다고만 하면 솔직히 좀 난해할 것 같습니다. 
- 위의 코드 내의 함수가 몇 번의 연산을 수행하는지 같이 한 번 보겠습니다. 

<img src="https://user-images.githubusercontent.com/83942393/135590922-b1a4b12f-6f92-46fd-8647-4a2afea90db9.png" width="80%"></img></br>
- 일단 02번째 줄에서 cnt 변수를 선언하고 0을 넣는 과정에서 1번, 03번째 줄에서 i 에 초기값으로 0을 대입할 때 1번, 그 다음 n번에 걸쳐 반복되는 일인데 03번째 줄을 보면 i가 n보다 작은지 확인하고, 작을 경우 1을 증가시키니 연산 2번, 04번째 줄에서 5로 나눈 나머지를 계산하고 0과 일치하는지 확인할 때 2번, 5의 배수이면 cnt를 1 증가시키니 1번, 마지막으로 cnt를 반환할 때 연산 1번이 필요합니다.
- 이렇게 뜯어보면 이 함수는 5n+3의 연산이 필요하다는걸 알 수 있습니다.
- n이 100만 정도 였으면 대략 500만 번의 연산이 필요하니 1초에 충분히 돌거고, n이 10억이였으면 대략 50억 번의 연산이 필요하니 1초 안에 다 돌 수가 없습니다.

<img src="https://user-images.githubusercontent.com/83942393/135591378-0a2ab74f-8086-43df-9719-6aa3d34d57ad.png" width="80%"></img></br>
- 하지만 저희가 인간 컴파일러도 아니고 코드를 매 실행 단위로 이렇게 하나하나 뜯어보는건 너무 심각한 노가다입니다.
- 그래서 이렇게 고생스럽게 뜯어보지 않고 상수는 떼고 적당히 n번의 연산이 필요하다. 좀 더 고상하게 말하면 n에 비례한다고 퉁쳐서 얘기합니다.

<img src="https://user-images.githubusercontent.com/83942393/135592224-cd91cc77-20d4-4bd8-879c-4435f42b3098.png" width="80%"></img></br>
- 지금부터 재미있는 수학 퍼즐을 푼다고 생각해보겠습니다.
- 얼마만큼의 시간이 필요할까요? 답을 생각해 보겠습니다.

<img src="https://user-images.githubusercontent.com/83942393/135591562-e1abbbbb-1e9e-4204-8b38-cd0e9c4fe037.png" width="80%"></img></br>
- 크게 어렵지는 않은 문제 같은데 어떤가요?
- 맨 앞부터 한명 한명 붙잡고 '가나다'씨가 맞는지 물어보면 됩니다.
- 운이 좋으면 물어보자마자 바로 찾을테니 1초이고, 최악의 경우는 '가나다'씨가 맨 뒤에 있을 경우 모든 사람에게 물어봐야 하니 N초이고, 평균적으로 절반쯤 물어보면 '가나다'씨를 찾을 수 있을테니 N/2초입니다.
- 그리고 이렇게 걸리는 시간은 N에 비례한다는걸 알 수 있습니다.
- 사람이 100명이면 대략 50초 정도 걸릴 거고, 사람이 10배 늘어나면 걸리는 시간도 10배 늘어나서 500초 정도 걸리게 될 것입니다.

<img src="https://user-images.githubusercontent.com/83942393/135592679-19c7fbb8-e603-40ff-a867-1bec1d1938d0.png" width="80%"></img></br>
- 이번에는 두 번째 문제입니다. 이건 얼마만큼의 시간이 필요할까요?

<img src="https://user-images.githubusercontent.com/83942393/135592742-49c0aef5-9ee6-4c14-aaa8-ab43b97b0c92.png" width="80%"></img></br>
- 아주 조금 낯설 수도 있지만, 술자리에서 업다운 게임을 떠올리면 도움이 될 것 같습니다.
- 마치 1에서 50 사이의 수에서 처음 하는 사람이 25를 부르는 것과 같이 N명의 사람들 중에서 가운데 있는 사람의 이름을 물었을 때 그 이름이 '바킹독'이어서 '가나다'보다 뒤에 있어야 하는 이름이면 '가나다'는 앞쪽 그룹에 있음을 알 수 있고, '가고일'과 같이 '가나다'보다 앞에 있어야 하는 이름이면 '가나다'는 뒤쪽 그룹에 있음을 알 수 있으므로 후보군을 절반으로 줄일 수 있습니다.
</br>

- 최선의 경우에는 맨 처음 물어본 사람이 '가나다'인 경우이고, 1초만에 '가나다'를 찾을 수 있습니다.
- 최악의 경우에는 한 명이 남을 때까지 절반으로 쪼개지는 상황이니, 원래 100명이었다면 50명, 25명, 12명, 6명, 3명, 1명까지 도달하면 '가나다'를 찾을 수 있습니다.
</br>

- 사람이 16명이면 4번, 32명이면 5번, 64명이면 6번, 이런식으로 계산을 할 때 마다 1/2씩 줄어드니 logN(앞으로 나오는 로그는 모두 밑이 2) 에 비례한다는 게 이해가 갈 것입니다.
- 평균적으로 logN인 이유는 엄밀히 수학적으로 기댓값을 계산해보면 (1-1/N)logN인데 1/N은 N이 커질 수록 0에 가까운 값이니 logN초 입니다. 깐깐하고 엄밀하게 확인하는 것에 관심이 없다면 그냥 최악의 경우에도 logN이고 평균적으로 logN이 걸리나보다 하고 받아들이면서 넘어가면 됩니다.

<img src="https://user-images.githubusercontent.com/83942393/135595389-45dc53f9-0a7d-4a06-8053-abda65075af7.png" width="80%"></img></br>
- 이 두 문제를 통해 저희는 시간복잡도라는 개념을 자연스럽게 익힐 수 있게 되었습니다.

<img src="https://user-images.githubusercontent.com/83942393/135595754-5d6b6574-d36b-4830-8aea-3db3ead2c3e4.png" width="80%"></img></br>
- 이제 여러 대표적인 시간복잡도를 그래프로 나타낸 것을 한번 확인해보겠습니다.
- 그래프만 봐도 N이 점점 커짐에 따라 시간 복잡도의 차이가 수행 시간에 아주 큰 영향을 준다는 것을 알 수 있습니다.
</br>

- 상수 시간인 O(1)이 가장 좋고, 그 다음으로는 O(logN)이고, 이후로 O(N), O(NlogN), O(N^2)등이 있습니다. 
- O(N)은 선형 시간이라 부르고, O(logN)부터 O(N^2)까지와 같이 logN 혹은 N의 거듭제곱끼리의 곱으로 시간 복잡도가 나타내어지면 이를 다항 시간이라고 합니다. 
</br>

- 팩토리얼은 지수 시간보다 훨씬 더 가파르게 올라갑니다.
- 당장 12!만 해도 거의 5억이라 O(N!)이 필요한 알고리즘도 지수 시간과 비슷하게 11 이하 정도로 굉장히 작은게 아니면 시간 제한을 통과하기 힘듭니다.

<img src="https://user-images.githubusercontent.com/83942393/135596482-0472f420-e30d-47a6-9613-228a6dcdeb70.png" width="80%"></img></br>
- 문제에서 주어지는 시간 제한은 대부분 1초에서 5초 사이 정도이므로 입력의 범위를 보고 문제에서 요구하는 시간 복잡도가 어느 정도인지 알 수 있습니다.
</br>

- 예를 들어 주어진 배열을 크기 순으로 정렬하는 문제를 생각해보면, 이 방법에는 O(NlogN)도 있고 O(N^2)의 방법도 있습니다.
- N이 1000이하라면 둘 중 어느 것을 쓰더라도 눈 깜빡할 사이에 정렬이 완료되지만, N이 100만이라면 O(NlogN)은 1초 내로 정렬되는 반면에, O(N^2)은 정렬이 완료될 떄까지 대략 1시간이 걸릴 것입니다.
</br>

- 표의 기준이 절대적인 것은 아닙니다. 그냥 표를 통해 대략적인 느낌만 가져가시면 됩니다. 
</br>

- 이제 우리는 문제를 풀 때 해야 할 일을 하나 더 알게 되었습니다.
- 주어진 문제를 보고 풀이를 떠올린 후에 무턱대로 바로 그걸 짜는게 아니라 내 풀이가 제한 시간 내로 통과할 수 있는지, 즉 내 알고리즘의 시간 복잡도가 올바른지를 꼭 생각해야 합니다. 
</br>

- 그러면 내 풀이의 시간 복잡도를 어떻게 알 수 있느냐라고 했을 때 어떻게 보면 쉽고, 어떻게 보면 어렵습니다.
- 대략 1부터 N까지의 수를 다 돌아야 하면 O(N), 우리가 구구단을 구현한 것처럼 이중 for문으로 돌면 O(N^2) 이런식으로 느낌은 잡을 수 있지만, 확실히 초보 단계에서 풀이나 코드의 시간 복잡도를 알아내는 게 꽤 어려웠다는 얘기를 많이 들어서 여러 예시들을 통해 같이 익혀보겠습니다.

<img src="https://user-images.githubusercontent.com/83942393/135597727-129dd898-1623-41f1-ad4a-f13da9fb61c3.png" width="80%"></img></br>
- 시간 복잡도 : O(N) (코드는 한 번에 맨 마지막에 있음)

<img src="https://user-images.githubusercontent.com/83942393/135598170-112e878b-e1ef-489d-b655-00589e896eda.png" width="80%"></img></br>
- 시간 복잡도 : O(n^2)

<img src="https://user-images.githubusercontent.com/83942393/135598213-746e49fa-ef7f-4600-b515-2379d06be009.png" width="80%"></img></br>
- 시간 복잡도 : O(루트 N) (이렇게 시간 복잡도 안에 루트가 들어갈 수도 있습니다.)

<img src="https://user-images.githubusercontent.com/83942393/135598292-1846f64f-72c6-42af-a55e-ab3237b8e156.png" width="80%"></img></br>
- 시간 복잡도 : O(logN)
- 이 방식의 시간 복잡도는 얼마일까요?
```
int func4(int n){
	int ret=1;

	while(2*ret <= n){
		ret *= 2;
	}

	return ret;
}
```
- N이 2^k 이상 2^(k+1) 미만이라고 할 때, 시간 복잡도가 O(k)이고 로그의 정의에 입각해서 생각할 때는 k는 logN이니 시간 복잡도는 O(logN)이 됩니다. 
</br>

- 전체 코드
```
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int func1(int N){
	int sum=0;
	for(int i=1; i<=N; i++){
		if(i%3==0 || i%5==0)
		sum+=i;
	}
	return sum; 
}

int func2(vector<int> arr, int n){
	for(int i=0; i<n; i++){
		for(int j=i+1; j<n; j++){
			if(arr[i]+arr[j]==100) return 1; 
		}
	}

	return 0; 
}

int func3(int n){

	for(int i=1; i*i <= n; i++){
		if(i*i == n) return 1;
	}

	return 0;

	// for(int i=2; i<=sqrt(n); i++){
	// 	if(i*i == n) return 1;
	// }
	// return 0; 
}

int func4(int n){
	int ret=1;

	while(2*ret <= n){
		ret *= 2;
	}

	return ret;
}

int main(){
	cout<<func1(16)<<endl;
	cout<<func1(34567)<<endl;
	cout<<func1(27639)<<endl;

	cout<<func2({1, 52, 48}, 3)<<endl;
	cout<<func2({50, 42}, 2)<<endl;
	cout<<func2({4, 13, 63, 87}, 4)<<endl;

	cout<<func3(9)<<endl;
	cout<<func3(693953651)<<endl;
	cout<<func3(756580036)<<endl;

	cout<<func4(5)<<endl;
	cout<<func4(97615282)<<endl;
	cout<<func4(1024)<<endl;
}
```

이렇게 시간 복잡도에 대해 알아보았습니다. </br>

<img src="https://user-images.githubusercontent.com/83942393/135780158-8e646db8-d0c5-4421-86ef-c424c998e79e.png" width="80%"></img></br>
- 공간복잡도는 입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계를 의미합니다.
- 예를 들어 크기 N짜리 2차원 배열이 필요하면 O(N^2)이고, 따로 배열이 필요 없으면 O(1)이 됩니다. 

<img src="https://user-images.githubusercontent.com/83942393/135780236-82a87286-2d0c-485a-898a-9f27c4fa4825.png" width="80%"></img></br>
- C언어를 배울 때 char 자료형은 1byte다 라는 표현을 들어본 적이 있을 것입니다. 
- 1byte는 8bit이니까 char 자료형의 값은 0 혹은 1이 들어가는 칸이 8칸이며, 이 칸을 이용해 표현된다는 의미입니다.
- char에서는 제일 왼쪽이 독특하게 -2^7입니다. 
- 이 부분이 이해가 잘 안가면 2's complement라는 개념을 찾아보셔도 되고, 굳이 이해를 하지 않고 넘어가셔도 상관은 없습니다. 

<img src="https://user-images.githubusercontent.com/83942393/135780588-37e30e8b-d36c-45d7-be88-4a362fcc77e1.png" width="80%"></img></br>
- 이건 unsigned char 와 char로 수를 표현하는 예시입니다. 
- unsigned char로 표현할 수 있는 수의 최솟값과 최댓값을 고민해보면, 최솟값은 00000000일 때 0일거고, 최댓값은 11111111일 때 255입니다.
- char에서도 표현할 수 있는 최솟값과 최댓값을 생각해보면, 최솟값은 10000000일 때 -128일거고, 최댓값은 01111111일 때 127입니다. 

<img src="https://user-images.githubusercontent.com/83942393/135780679-634dad24-dffc-4457-9801-8800857535d3.png" width="80%"></img></br>
- 각각이 표현할 수 있는 최댓값을 확인하면 각각 32767, 약 2.1x10^9 (21억), 9.2 x 10^18 까지 표현할 수 있습니다.
- 요즘은 패치가 됐지만 옛날엔 메이플 최대 메소가 2^31-1인 2147483647 이었습니다. 
</br>

- short는 딱히 쓸 일이 없고, 주로 int나 longlong을 쓰는데, int가 longlong보다 연산 속도와 메모리 모두 우수하지만, 80번째 피보나치 수를 구하는 문제와 같이 int 자료형이 표현할 수 없는 범위를 넘어서는 수를 저장해야 한다면 반드시 longlong자료형을 사용해야 합니다. 

<img src="https://user-images.githubusercontent.com/83942393/135781112-f3cc6e1e-63c2-45cd-99f5-ed1bd8656243.png" width="80%"></img></br>

<img src="https://user-images.githubusercontent.com/83942393/135781158-887ee412-58ed-4180-8ba2-4cae4eb52733.png" width="80%"></img></br>
- Integer Overflow를 막는 방법은 아주 쉽습니다. 각 자료형의 범위에 맞는 값을 가지게끔 연산을 시키면 됩니다.
- 하지만 실제 코드를 짜다 보면 Integer Overflow는 아주 빈번하게 일어나고, 찾기도 매우 힘듭니다. 

- 3가지 함수중에서 Interger Overflow가 발생할 수 있는 함수가 무엇인지, 어느 부분에서 발생하는지를 찾아보겠습니다.
- 3개의 함수 중에서 Integer Overflow로 인해 의도한대로 동작하지 않는 함수는 func1과 func3입니다.
</br>

- func1의 경우에는 s가 127이 된 후에 1을 증가시킬 때, 127에 1이 더해지면 -128이기 때문에 무한루프에 빠집니다.
- 이를 해결하려면 s의 자료형을 char에서 int로 바꿔야 합니다.
- func3에서는 a가 10^9일 때 여기서 10이 곱해지는 순간 int의 최대 범위를 넘어서서 Integer Overflow가 발생합니다.
- 이걸 막으려면 a의 자료형을 longlong으로 바꾸거나, 07번째 줄에서 10대신 10ll 혹은 (long long)10으로 강제 형변환을 시키면 해결할 수 있습니다.
</br>

- 머리로는 Integer Overflow를 익혔지만, 실제로 문제를 풀 떄 실수를 여러 번 저지르게 될 것입니다.
- 그래도 이 실수로 시간을 엄청 버리고 나면 그 다음엔 실수를 덜하게 될 것입니다.
- 만약 문제에서 unsigned long long 범위를 벗어나는 수를 저장할 것을 요구한다면, string을 활용해서 저장해야 합니다.

<img src="https://user-images.githubusercontent.com/83942393/135782313-e388d0ab-4547-4266-8f7f-21e7cdaf1a5f.png" width="80%"></img></br>

<img src="https://user-images.githubusercontent.com/83942393/135796284-7d7aba85-dac5-49b4-8b80-8583a7e3c01e.png" width="80%"></img></br>
															    
- 상대 오차가 10^-15까지 안전하다는 표현은, 원래 참값이 1이라고 할 때, 1-10^-15에서 1+10^-15 사이의 값을 가진다는 게 보장이 된다는 의미입니다. 
- 즉, 오차가 생기는 것 자체는 막을 수 없지만, 오차가 어느 정도인지는 알 수 있습니다.
</br>

- 상대 오차의 허용 범위에서 볼 수 있듯 두 자료형끼리 차이가 굉장히 크기 때문에, 실수 자료형이 필요하면 꼭 float 대신 double을 써야 합니다. 
- float이 메모리를 적게 쓴다는 장점이 있으니 메모리가 정말 소중하면 필요할 수도 있긴 하지만, 적어도 저는 지금까지 알고리즘 문제를 풀면서 double 대신 float을 써야 하는 상황을 경험해본 적이 없습니다. 
- 또 실수 자료형은 필연적으로 오차가 있으니까, 실수 자료형이 필요하면 보통 문제에서 절대/상대 오차를 허용한다는 단서를 줍니다.
- 그런데 만약, 이런 표현이 없다면 열에 아홉은 실수를 안쓰고 모든 연산을 정수에서 해결할 수 있는 문제일 것입니다.

<img src="https://user-images.githubusercontent.com/83942393/135796809-3e468ff1-30f8-4f54-a862-d4a514e43d45.png" width="80%"></img></br>
- 두 번째로, double에 long long 범위의 정수를 함부로 담으면 안됩니다. 
- double은 유효숫자가 15자리인데, long long은 최대 19자리니까 10^18+1과 10^18을 구분할 수 없고, 같은 값이 저장됩니다.
- 즉, double에 long long 범위의 정수를 담을 경우 오차가 섞인 값이 저장될 수 있습니다.
- 다만, int는 최대 21억이기 때문에 double에 담아도 오차가 생기지 않습니다. 

<img src="https://user-images.githubusercontent.com/83942393/135797009-c3794394-17ce-4e19-bf79-9d4626650803.png" width="80%"></img></br>
- 마지막으로 실수를 비교할 때는 등호를 사용하면 안됩니다.
- 이건 0.1+0.1+0.1 과 0.3이 일치하지 않았던 걸로 이미 보셨을텐데, 오차 때문에 두 실수가 같은지 알고 싶을 때에는 둘의 차이가 아주 작은 값, 대략 10^-12 이하면 동일하다고 처리를 하는게 안전합니다.
</br>

- 5번째 줄의 1e-12가 처음 보는 표현일 수 있을 것 같은데, 저게 바로 10^-12입니다.
- 비슷하게 만약 10^9가 필요하면, 1000000000이라고 써도 되긴 하지만, 이렇게 쓰면 0 갯수를 세기 힘드므로 대신 1e9라고 써도 됩니다.

- 5번째 줄의 1e-12가 처음 보는 표현일 수 있을 것 같은데, 저게 바로 10^-12입니다.ㅁㅏㄴ약
- 5번째 줄의 1e-12가 처음 보는 표현일 수 있을 것 같은데, 저게 바로 10^-12입니다.
- 이건 0.1+0.1+0.1 과 0.3이 일치하지 않았던 걸로 이미 보셨을텐데, 오차 때문에 두 실수가 같은지 알고 싶을 때에는 둘의 차이가 아주 작은 값, 대략 10^-12 이하면 동일하다고 처리를 하는게 안전합니다5ㅂ
- 이건 0.1+0.1+0.1 과 0.3이 일치하지 않았던 걸로 이미 보셨을텐데, 오차 때문에 두 실수가 같은지 알고 싶을 때에는 둘의 차이가 아주 작은 값, 대략 10^-12 이하면 동일하다고 처리를 하는게 안전합니
ㅅㅣㄹ수를
