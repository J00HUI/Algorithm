## 1강. 기초 코드 작성 요령 1
### Contents
1. 시간, 공간 복잡도
2. 정수 자료형
3. 실수 자료형

### 1. 시간, 공간 복잡도
![R1280x0](https://user-images.githubusercontent.com/83942393/135589325-44423484-e861-46ac-b1da-adcf0dc8ab75.png) <br>
- 시간 제한이 1초라고 되어 있는데, 컴퓨터는 1초에 대략 3-5억 개 정도의 연산을 처리할 수 있습니다. (단, 연산이 비트 AND, OR, 비교, 덧셈과 같은 단순한 연산인지, 아니면 나눗셈, 곱셈, 대입, 함수 호출과 같은 복잡한 연산인지에 따라 횟수에 조금 차이가 날 수 있어, 3-5억이라는 값은 어림 잡은 값이라는 것을 주의해야 합니다.)
- 이 코드는 연산을 몇 번 할지 생각해봅시다.
- 05번째 줄에서 두 변수를 입력 받을 때 두 번, 06번째 줄에서 두 수를 더하고 출력할 때 연산이 필요하니 대충 3, 4번의 연산이 필요합니다. 
- 그러므로, 1초 내로는 충분히 프로그램이 모든 명령을 수행한 후 종료되고, 엄밀히 말하면 0.000001초도 안 걸릴 것입니다. 
- 그러면 이제 시간 제한이 우리에게 어떤걸 알려주는 지 조금 감이 올 것입니다.
- 예를 들어, 시간 제한이 1초라고 하면, 이건 "당신의 프로그램은 3-5억 번의 연산 안에 답을 내고 종료되어야 한다"라는 것을 알려주는 것입니다.

![R1280x0](https://user-images.githubusercontent.com/83942393/135590277-e546b6d0-b4ce-4fe0-8786-ef76b95d35ef.png)
- 그런데, 3-5억 번의 연산이 필요하다고만 하면 솔직히 좀 난해할 것 같습니다. 
- 위의 코드 내의 함수가 몇 번의 연산을 수행하는지 같이 한 번 보겠습니다. 

![R1280x0-3](https://user-images.githubusercontent.com/83942393/135590922-b1a4b12f-6f92-46fd-8647-4a2afea90db9.png)
- 일단 02번째 줄에서 cnt 변수를 선언하고 0을 넣는 과정에서 1번, 03번째 줄에서 i 에 초기값으로 0을 대입할 때 1번, 그 다음 n번에 걸쳐 반복되는 일인데 03번째 줄을 보면 i가 n보다 작은지 확인하고, 작을 경우 1을 증가시키니 연산 2번, 04번째 줄에서 5로 나눈 나머지를 계산하고 0과 일치하는지 확인할 때 2번, 5의 배수이면 cnt를 1 증가시키니 1번, 마지막으로 cnt를 반환할 때 연산 1번이 필요합니다.
- 이렇게 뜯어보면 이 함수는 5n+3의 연산이 필요하다는걸 알 수 있습니다.
- n이 100만 정도 였으면 대략 500만 번의 연산이 필요하니 1초에 충분히 돌거고, n이 10억이였으면 대략 50억 번의 연산이 필요하니 1초 안에 다 돌 수가 없습니다.

![R1280x0-4](https://user-images.githubusercontent.com/83942393/135591378-0a2ab74f-8086-43df-9719-6aa3d34d57ad.png)
- 하지만 저희가 인간 컴파일러도 아니고 코드를 매 실행 단위로 이렇게 하나하나 뜯어보는건 너무 심각한 노가다입니다.
- 그래서 이렇게 고생스럽게 뜯어보지 않고 상수는 떼고 적당히 n번의 연산이 필요하다. 좀 더 고상하게 말하면 n에 비례한다고 퉁쳐서 얘기합니다.

![R1280x0-6](https://user-images.githubusercontent.com/83942393/135592224-cd91cc77-20d4-4bd8-879c-4435f42b3098.png)
- 지금부터 재미있는 수학 퍼즐을 푼다고 생각해보겠습니다.
- 얼마만큼의 시간이 필요할까요? 답을 생각해 보겠습니다.

![R1280x0-5](https://user-images.githubusercontent.com/83942393/135591562-e1abbbbb-1e9e-4204-8b38-cd0e9c4fe037.png)
- 크게 어렵지는 않은 문제 같은데 어떤가요?
- 맨 앞부터 한명 한명 붙잡고 '가나다'씨가 맞는지 물어보면 됩니다.
- 운이 좋으면 물어보자마자 바로 찾을테니 1초이고, 최악의 경우는 '가나다'씨가 맨 뒤에 있을 경우 모든 사람에게 물어봐야 하니 N초이고, 평균적으로 절반쯤 물어보면 '가나다'씨를 찾을 수 있을테니 N/2초입니다.
- 그리고 이렇게 걸리는 시간은 N에 비례한다는걸 알 수 있습니다.
- 사람이 100명이면 대략 50초 정도 걸릴 거고, 사람이 10배 늘어나면 걸리는 시간도 10배 늘어나서 500초 정도 걸리게 될 것입니다.

![R1280x0-7](https://user-images.githubusercontent.com/83942393/135592679-19c7fbb8-e603-40ff-a867-1bec1d1938d0.png)
- 이번에는 두 번째 문제입니다. 이건 얼마만큼의 시간이 필요할까요?

![R1280x0-8](https://user-images.githubusercontent.com/83942393/135592742-49c0aef5-9ee6-4c14-aaa8-ab43b97b0c92.png)
- 아주 조금 낯설 수도 있지만, 술자리에서 업다운 게임을 떠올리면 도움이 될 것 같습니다.
- 마치 1에서 50 사이의 수에서 처음 하는 사람이 25를 부르는 것과 같이 N명의 사람들 중에서 가운데 있는 사람의 이름을 물었을 때 그 이름이 '바킹독'이어서 '가나다'보다 뒤에 있어야 하는 이름이면 '가나다'는 앞쪽 그룹에 있음을 알 수 있고, '가고일'과 같이 '가나다'보다 앞에 있어야 하는 이름이면 '가나다'는 뒤쪽 그룹에 있음을 알 수 있으므로 후보군을 절반으로 줄일 수 있습니다.
</br>

- 최선의 경우에는 맨 처음 물어본 사람이 '가나다'인 경우이고, 1초만에 '가나다'를 찾을 수 있습니다.
- 최악의 경우에는 한 명이 남을 때까지 절반으로 쪼개지는 상황이니, 원래 100명이었다면 50명, 25명, 12명, 6명, 3명, 1명까지 도달하면 '가나다'를 찾을 수 있습니다.
</br>

- 사람이 16명이면 4번, 32명이면 5번, 64명이면 6번, 이런식으로 계산을 할 때 마다 1/2씩 줄어드니 logN(앞으로 나오는 로그는 모두 밑이 2) 에 비례한다는 게 이해가 갈 것입니다.
- 평균적으로 logN인 이유는 엄밀히 수학적으로 기댓값을 계산해보면 (1-1/N)logN인데 1/N은 N이 커질 수록 0에 가까운 값이니 logN초 입니다. 깐깐하고 엄밀하게 확인하는 것에 관심이 없다면 그냥 최악의 경우에도 logN이고 평균적으로 logN이 걸리나보다 하고 받아들이면서 넘어가면 됩니다.

![R1280x0-9](https://user-images.githubusercontent.com/83942393/135595389-45dc53f9-0a7d-4a06-8053-abda65075af7.png)
- 이 두 문제를 통해 저희는 시간복잡도라는 개념을 자연스럽게 익힐 수 있게 되었습니다.

![R1280x0-10](https://user-images.githubusercontent.com/83942393/135595754-5d6b6574-d36b-4830-8aea-3db3ead2c3e4.png)
- 이제 여러 대표적인 시간복잡도를 그래프로 나타낸 것을 한번 확인해보겠습니다.
- 그래프만 봐도 N이 점점 커짐에 따라 시간 복잡도의 차이가 수행 시간에 아주 큰 영향을 준다는 것을 알 수 있습니다.
</br>

- 상수 시간인 O(1)이 가장 좋고, 그 다음으로는 O(logN)이고, 이후로 O(N), O(NlogN), O(N^2)등이 있습니다. 
- O(N)은 선형 시간이라 부르고, O(logN)부터 O(N^2)까지와 같이 logN 혹은 N의 거듭제곱끼리의 곱으로 시간 복잡도가 나타내어지면 이를 다항 시간이라고 합니다. 
</br>

- 팩토리얼은 지수 시간보다 훨씬 더 가파르게 올라갑니다.
- 당장 12!만 해도 거의 5억이라 O(N!)이 필요한 알고리즘도 지수 시간과 비슷하게 11 이하 정도로 굉장히 작은게 아니면 시간 제한을 통과하기 힘듭니다.

![R1280x0-11](https://user-images.githubusercontent.com/83942393/135596482-0472f420-e30d-47a6-9613-228a6dcdeb70.png)
- 문제에서 주어지는 시간 제한은 대부분 1초에서 5초 사이 정도이므로 입력의 범위를 보고 문제에서 요구하는 시간 복잡도가 어느 정도인지 알 수 있습니다.
</br>

- 예를 들어 주어진 배열을 크기 순으로 정렬하는 문제를 생각해보면, 이 방법에는 O(NlogN)도 있고 O(N^2)의 방법도 있습니다.
- N이 1000이하라면 둘 중 어느 것을 쓰더라도 눈 깜빡할 사이에 정렬이 완료되지만, N이 100만이라면 O(NlogN)은 1초 내로 정렬되는 반면에, O(N^2)은 정렬이 완료될 떄까지 대략 1시간이 걸릴 것입니다.
</br>

- 표의 기준이 절대적인 것은 아닙니다. 그냥 표를 통해 대략적인 느낌만 가져가시면 됩니다. 
</br>

- 이제 우리는 문제를 풀 때 해야 할 일을 하나 더 알게 되었습니다.
- 주어진 문제를 보고 풀이를 떠올린 후에 무턱대로 바로 그걸 짜는게 아니라 내 풀이가 제한 시간 내로 통과할 수 있는지, 즉 내 알고리즘의 시간 복잡도가 올바른지를 꼭 생각해야 합니다. 
</br>

- 그러면 내 풀이의 시간 복잡도를 어떻게 알 수 있느냐라고 했을 때 어떻게 보면 쉽고, 어떻게 보면 어렵습니다.
- 대략 1부터 N까지의 수를 다 돌아야 하면 O(N), 우리가 구구단을 구현한 것처럼 이중 for문으로 돌면 O(N^2) 이런식으로 느낌은 잡을 수 있지만, 확실히 초보 단계에서 풀이나 코드의 시간 복잡도를 알아내는 게 꽤 어려웠다는 얘기를 많이 들어서 여러 예시들을 통해 같이 익혀보겠습니다.

![R1280x0-12](https://user-images.githubusercontent.com/83942393/135597727-129dd898-1623-41f1-ad4a-f13da9fb61c3.png)
- 시간 복잡도 : O(N) (코드는 한 번에 맨 마지막에 있음)

![R1280x0-13](https://user-images.githubusercontent.com/83942393/135598170-112e878b-e1ef-489d-b655-00589e896eda.png)
- 시간 복잡도 : O(n^2)

![R1280x0-14](https://user-images.githubusercontent.com/83942393/135598213-746e49fa-ef7f-4600-b515-2379d06be009.png)
- 시간 복잡도 : O(루트 N) (이렇게 시간 복잡도 안에 루트가 들어갈 수도 있습니다.)

![R1280x0-15](https://user-images.githubusercontent.com/83942393/135598292-1846f64f-72c6-42af-a55e-ab3237b8e156.png)
- 시간 복잡도 : O(logN)
- 이 방식의 시간 복잡도는 얼마일까요?
```
int func4(int n){
	int ret=1;

	while(2*ret <= n){
		ret *= 2;
	}

	return ret;
}
```
- N이 2^k 이상 2^(k+1) 미만이라고 할 때, 시간 복잡도가 O(k)이고 로그의 정의에 입각해서 생각할 때는 k는 logN이니 시간 복잡도는 O(logN)이 됩니다. 
</br>

- 전체 코드
```
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

int func1(int N){
	int sum=0;
	for(int i=1; i<=N; i++){
		if(i%3==0 || i%5==0)
		sum+=i;
	}
	return sum; 
}

int func2(vector<int> arr, int n){
	for(int i=0; i<n; i++){
		for(int j=i+1; j<n; j++){
			if(arr[i]+arr[j]==100) return 1; 
		}
	}

	return 0; 
}

int func3(int n){

	for(int i=1; i*i <= n; i++){
		if(i*i == n) return 1;
	}

	return 0;

	// for(int i=2; i<=sqrt(n); i++){
	// 	if(i*i == n) return 1;
	// }
	// return 0; 
}

int func4(int n){
	int ret=1;

	while(2*ret <= n){
		ret *= 2;
	}

	return ret;
}

int main(){
	cout<<func1(16)<<endl;
	cout<<func1(34567)<<endl;
	cout<<func1(27639)<<endl;

	cout<<func2({1, 52, 48}, 3)<<endl;
	cout<<func2({50, 42}, 2)<<endl;
	cout<<func2({4, 13, 63, 87}, 4)<<endl;

	cout<<func3(9)<<endl;
	cout<<func3(693953651)<<endl;
	cout<<func3(756580036)<<endl;

	cout<<func4(5)<<endl;
	cout<<func4(97615282)<<endl;
	cout<<func4(1024)<<endl;
}
```

이렇게 시간 복잡도에 대해 알아보았습니다. </br>




