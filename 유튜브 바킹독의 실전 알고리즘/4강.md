## 4강. 연결 리스트
<img src="https://user-images.githubusercontent.com/83942393/136785231-2128b2af-21fe-435d-be32-029b96b1c76d.png" width="80%"></img></br>

- 연결리스트는 원소들을 저장할 때, 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조입니다.
- 원소들은 이곳 저곳에 흩어져 있습니다.
</br>

- 실행활의 예시를 들어보면, 제가 학교 선생님이고 전체 학생 중에서 영은, 현지, 재현, 상혁 학생 4명을 술래로 정했고, 이 4명을 기억하고 싶습니다.
- 이런 상황일 때, 배열이라면 그냥 4칸짜리 배열을 만들고 4명을 저장하면 될 것입니다.
</br>

- 그런데, 연결 리스트의 관점에서는 영은이가 현지를 기억하고, 현지는 재현이를 기억하고, 재현이는 상혁이를 기억하는 것입니다.
- 이렇게 되면, 저는 영은이만 외우고 있으면 됩니다.
- 그리고 4명 전체가 필요하면 저는 영은이를 통해 나머지 3명이 누구였는지를 알아낼 수 있게 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136785716-9861cf21-4ca0-4d82-9d86-29a6ada76228.png" width="80%"></img></br>
- 자 그러면 연결리스트의 성질이 어떤지 보겠습니다.
- 배열과 연결 리스트를 비교하는 경우가 많기 때문에, 배열에서는 어땠는지를 떠올리면서 봐도 좋습니다.
</br>

- 첫 번째로, 연결리스트에서 k번째 원소를 찾기 위해 O(k)의 시간이 필요합니다. 
- 3, 13, 72, 5를 저장하는 연결 리스트에서 3번째 원소를 찾고 싶으면 3을 거쳐 13을 가고, 13을 거쳐 72로 가야합니다. 이렇게 가지 않고서는 3번째 원소에 무엇이 있는지 알 방법이 없습니다. 배열과 다르게 공간에 원소들이 연속해서 위치하고 있지 않기 때문입니다. 
</br>

- 두 번째로 연결 리스트에서는 임의의 위치에 원소를 추가하거나 임의의 위치의 원소 제거가 O(1)입니다.
- 이 성질이 배열과 비교했을 때 큰 차이가 있는 성질이고, 연결 리스트의 큰 장점이기도 합니다. (배열은 임의의 위치에 원소를 추가하거나 삭제할 때, 원소들을 옮겨야 한다. (맨 뒤 삽입, 삭제 시 예외)
</br>

- 세 번째로 메모리 상에 데이터들이 연속해있지 않으니까 cache hit rate 가 낮지만 할당이 쉽습니다. 이 성질은 코딩 테스트를 칠 때는 몰라도 상관 없습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136786530-942640bd-e16e-478a-b444-536079e53a2f.png" width="80%"></img></br>
- 배열과 다르게 연결 리스트에는 몇 개의 종류가 있는데 같이 한 번 살펴보겠습니다.
</br>

- 첫 번째는 단일 연결 리스트입니다.
- 단일 연결리스트는 각 원소가 자신의 다음 원소의 주소를 들고 있는 연결 리스트입니다.
</br>

- 두 번째는 이중 연결 리스트입니다.
- 이중 연결 리스트에서는 각 원소가 자신의 이전 원소와 다음 원소의 주소를 둘 다 들고 있습니다.
- 단일 연결 리스트에서는 주어진 원소의 이전 원소가 무엇인지 알 수 없었는데, 이중 연결 리스트에서는 알 수 있습니다.
- 다만, 원소가 가지고 있어야 하는 정보가 1개 더 추가되니 메모리를 더 쓴다는 단점이 있습니다.
- 참고로 STL에 연결 리스트가 있는데, 이 컨테이너의 이름은 list이고, 구조는 이중 연결 리스트입니다. 
</br>

- 세 번째는 원형 연결 리스트입니다.
- 원혈 연결 리스트에서는 끝이 처음과 연결되어 있습니다.
- 그림의 예시는 단일 연결 리스트로 표현했지만, 각 원소가 이전과 다음 원소의 주소를 모두 들고 있어도 상관 없습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136787082-03a7fc0f-c8ce-4629-b3e6-b13e6aac6423.png" width="80%"></img></br>
- 배열과 연결 리스트는 메모리 상에 원소를 놓는 방법이 다르다고 해도, 어찌됐든 원소들 사이의 선후 관계가 일대일로 정의됩니다.
- 즉, 원소들 사이에서 첫 번째 원소, 두 번째 원소, ... 이런 개념이 존재하는 것입니다. 
- 그래서 배열과 연결리스트는 선형 자료구조라고 불립니다.
- 트리, 그래프, 해쉬 등은 비선형 자료구조의 대표적인 예시입니다.
</br>

- 배열과 연결 리스트는 둘 다 선형 자료구조여서 면접에서 둘의 비교하는 문제를 구술 시험으로 내기도 합니다. 
- 꼭 면접 대비가 아니라고 하더라도, 둘의 차이를 알아야 적재적소에 배열이나 연결 리스트를 잘 써먹을 수 있을테니, 둘의 장단점을 비교하는 시간을 가져보도록 하겠습니다. 
</br>

- 첫 번째로 k번째 원소의 접근은 배열의 경우 O(1), 연결 리스트의 경우 O(k)입니다.
</br>

- 두 번째로 임의 위치에 원소를 추가하거나 제거하는 경우에는 배열의 경우 O(N), 연결 리스트의 경우 O(1)입니다.
- 그런데, 엄밀히 말해서 연결 리스트에서도 3번째 원소 뒤에 20이라는 원소를 추가하고 싶다면, 일단 3번째 원소까지 찾아간 뒤에 O(1)에 추가가 가능한 거라 상황이 조금 다르긴 하지만, 이 부분은 구현 파트에서 자세히 다루겠습니다.
</br>

- 메모리 상의 배치는 배열의 경우 연속적이고, 연결 리스트의 경우 불연속적입니다.
- 마지막으로 추가적으로 필요한 공간, 즉 overhead 를 생각해보면 배열은 데이터만 딱딱 저장하면 될 뿐 딱히 추가적으로 필요한 공간이 없습니다.
- 굳이 따지면 길이 정보를 저장할 int 1개가 필요할 수 있지만, 이건 너무 미미하니 신경을 쓸 필요가 없을 정도입니다. 
- 그런데, 연결 리스트에서는 각 원소가 다음 원소, 혹은 이전과 다음 원소의 주소값을 가지고 있어야 합니다.
- 그래서 32비트 컴퓨터이면 주소값이 32비트(=4바이트) 단위이니 4N 바이트가 추가로 필요하고, 64비트 컴퓨터라면 주소값이 64비트(=8바이트) 단위이니 8N 바이트가 추가로 필요합니다. 
- 즉, N에 비례하는 만큼의 메모리를 추가로 쓰게 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136788508-a25243bd-f71e-4c33-bb2f-1170bc1284ab.png" width="80%"></img></br>
- 이제 연결 리스트에서 제공되는 연산들을 하나씩 살펴보겠습니다.
- 첫 번째로, 임의의 위치에 있는 원소를 확인/변경하는 연산입니다.
- k 번째 원소를 보기 위해서는 O(k)의 시간이 필요하고, 전체에 N개의 원소가 있다고 하면 평균적으로 O(N)이라고 생각하면 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136788785-c5a9ff2e-596e-47fe-a519-29b6ca83da75.png" width="80%"></img></br>
- 두 번째로 임의의 위치에 원소를 추가하는 연산인데, 이건 O(1)에 가능합니다.
- 예를 들어, 21뒤에 84를 추가하고 싶다고 할 때, 배열처럼 그 뒤의 원소들을 전부 옮기는 작업을 할 필요가 없고, 그냥 21과 84에서 다음 원소의 주소만 변경 해주면 되기 떄문입니다. 
- 단, 착각하면 안되는게 있는데, 추가하고 싶은 위치의 주소를 알고 있을 경우에만 O(1)입니다.
- 만약, 21의 주소를 준게 아니라, 그냥 84라는 원소를 세 번째 원소 뒤에 추가하라는 명령의 경우에는, 세 번째 원소까지 찾아가야 하는 시간이 추가로 걸려서 O(1)이라고 말할 수 없습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136789364-9dce971f-6acd-4634-924c-84f8d6d0e858.png" width="80%"></img></br>
- 마지막으로 임의의 위치의 원소를 제거하는 연산이고, 이것 또한 O(1)에 가능합니다.
- 한 번 21을 지워보겠습니다.
- 21을 지우려면 딱 1개만 하면 되는데, 65에 "너의 다음 원소는 21이 아닌 17이다"라고만 알려주면 끝입니다.
- 물론 그 다음 21이 들어있는 원소는 메모리 누수를 막기 위해 메모리에서 없애줄 필요가 있습니다. 
- 이 경우에도 마찬가지로, 세 번째 원소를 삭제하라고 한다면 세 번째 원소까지 찾아가야 하는 시간이 추가로 걸린다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136789732-c238dcca-b515-4514-843e-fa68f113551c.png" width="80%"></img></br>
- 정리를 해보면, 임의의 위치에 있는 원소를 확인하거나 변경하는건 O(N)이고, 해당 위치의 주소를 같이 넘겨줄 때, 임의의 위치에 원소를 추가하거나 임의의 위치에 원소를 제거하는 건 O(1)입니다.
</br>

- 저희가 지금 연결 리스트를 다루고는 있는데, 배열이 너무 익숙하다보니 이런 자료구조를 어디에 써먹을 수 있나 싶겠지만, 연결 리스트가 쓰이는 대표적인 상황이 바로 메모장과 같은 텍스트 에디터입니다.
- 물론 실제 텍스트 에디터는 매 순간순간마다 화면에 결과를 출력해야 하니 아마도 그냥 배열로 구현을 할 것 같습니다. 
</br>

- 그러나 예를 들어, 커서를 옮기고 글자를 지우는 것과 같은 연산들이 다양하게 주어진 후, 최종 결과를 출력하라는 문제라고 한다면, 우리는 커서가 가리키는 위치에 글자를 추가하거나 글자를 지우는 명령을 계속 수행해야 합니다. 
- 이런 경우에 배열은 임의의 위치에 글자를 추가하는 연산이 비효율적인데, 연결 리스트에서는 O(1)에 처리할 수 있어 연결 리스트로 구현할 경우에 효율적일 수 있습니다. 
</br>

- 그러므로, 임의의 위치에 원소를 추가하거나 제거하는 연산을 많이 해야 할 경우에는 연결 리스트의 사용을 고려해보면 좋습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136790414-c27087a1-275b-435a-b84d-85046efbbebe.png" width="100%"></img></br>
- 원래 연결 리스트의 정성적인 구현은 NODE 구조체나 클래스를 만들어서 원소가 생성될 때마다 동적할당하는 방식입니다. 
- 이 방식은 면접에서 손코딩을 시킨다거나 하는 방식으로 질문을 할 수가 있기 때문에 개인적으로 공부를 하셔야 합니다. 
</br>

- 그런데 이 구현은 긴박한 코딩테스트에서 쓰기는 별로 좋지가 않습니다. 
- 코딩테트에서는 STL의 list를 활용하면 됩니다. 
- STL list 에서는 Doubly Linked List 구조를 가지고 있기 때문에 연결 리스트가 필요하다면 가져다 쓰면 됩니다.
- 그런데 만약 코딩테스트에서 STL을 허용하지 않는다면 직접 연결 리스트를 구현해야 합니다.
- STL을 허용하지 않는 코딩테스트가 정말 드물긴 한데, 연결 리스트를 정성적으로 구현하는 대신, 야매로 구현하면 구현 난이도가 크게 높지 않아 연결 리스트를 연습하는 셈치고 야매 연결 리스트를 소개해드리겠습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136790965-b1a69c5c-faf4-4c9f-9cb5-5c189569e4d3.png" width="100%"></img></br>
- 이 야매 연결 리스트는 원소를 배열로 관리하고, pre와 nxt에 이전/다음 원소의 포인터 대신 배열 상의 인덱스를 저장하는 방식으로 구현한 연결 리스트입니다. 
- 메모리 누수 문제 때문에 실무에서는 절대 쓸 수 없는 방식이지만, 코딩 테스트에서는 구현 난이도가 일반적인 연결 리스트보다 낮고 시간 복잡도도 동일하기 때문에 애용하면 됩니다. 
</br>

- 구현에 필요한 변수들을 보면 dat\[i]는 i번지 원소의 값, pre\[i]는 i번지 원소에 대해 이전 원소의 인덱스, nxt\[i]는 다음 원소의 인덱스입니다.
- pre나 nxt의 값이 -1이면 해당 원소의 이전/다음 원소가 존재하지 않는다는 의미입니다.
- unused는 현재 사용되지 않는 인덱스, 즉 새로운 원소가 들어갈 수 있는 인덱스이고, 원소가 추가된 후에는 1씩 증가됩니다.
- 특별히 0번지는 연결 리스트의 시작 원소로 고정되어 있습니다. 
- 달리 말하면 0번지는 값이 들어가지 않고, 단지 시작점을 나타내기 위한 dummy node 입니다. 
- 지금 코드상에는 별도로 길이 정보를 두지 않았지만, 길이가 필요하다면 따로 len 변수를 두고, 원소가 추가될 때 1씩 증가시키고 제거될 때 1씩 감소시키면 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136791648-642f334a-58eb-4b05-b029-63adb1d19909.png" width="80%"></img></br>
- 주어진 연결 리스트는 13, 65, 21, 17이라는 값을 가지고 있습니다.
- 그리고 이들은 각각 배열에서 2번지, 1번지, 4번지, 5번지에 저장되어 있다고 생각하겠습니다.
- 이 위치들은 임의로 정한 위치이고, 실제로는 1번지부터 unused가 가리키고 있는 한칸 전까지 사이에서 아무데나 위치하게 됩니다. 
</br>

- 그리고 특별히 0번지에는 연결 리스트의 시작 원소로 고정되어 있습니다.
- 즉, 실제로 값이 들어있는 것은 아니지만 관념적으로 연결 리스트의 제일 앞에 원소 하나가 있다고 생각할 것 입니다. 
- 왜그렇게 하나면, 이런 dummy node를 두지 않으면 나중에 삽입과 삭제 등의 기능을 구현할 때, 원소가 아예 없는 경우에 대한 예외처리를 해야 하는데, 관념적으로 dummy node를 두면 예외처리가 덜 번거로워져서 그렇습니다. 
</br>

- dummy node 의 dat는 의미가 없으니 -1로 두고, pre는 해당 원소의 이전 원소가 존재하지 않으니 -1이고, nxt는 13이 들어있는 주소인 2번지의 2가 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136898139-0a12cb6c-d219-4b5d-be59-fb615b7381b0.png" width="100%"></img></br>
- 이제 각 기능들을 구현해보는 시간을 가질텐데, travers 함수는 먼저 같이 구현해보겠습니다. 
- travers 함수에서는 연결 리스트의 모든 원소들을 출력할 것입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136898290-1a6d0ab7-1d05-433d-a6cb-616954a0c037.png" width="100%"></img></br>
- 남은건 insert와 erase 함수입니다.
- 구현 전에 설명을 드리도록 하겠습니다.
</br>

- 두 함수에 공통으로 있는 인자인 addr은 앞에서 말한 각 원소의 주소, 즉 배열 상에서 몇 번지인지를 의미합니다.
- 예를 들어 원소 13이 2번지이고, 13뒤에 20을 새로 추가하고 싶다면, insert(2, 20)을 호출해야 하고, 13을 지우고 싶다면 erase(2)를 호출해야 합니다.
- addr=2가 의미하는 것이, 연결 리스트 상에서 2번째 원소라는 것이 아니라, 해당 원소의 주소가 2번지라는 점을 꼭 헷갈리면 안됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136898619-27a85eb1-7a48-4d02-875d-819b020b480c.png" width="100%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/136898686-a3031ffa-5c05-46b7-8329-40d093a5b87a.png" width="100%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/136898769-9062c581-95b2-4834-a61f-188e5cbd85dc.png" width="100%"></img></br>
- 이제 이 과정을 따라서 구현을 하면 됩니다.
- 먼저 시도를 해보고, 제 코드를 확인해보세요.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136898852-257732fb-4a09-49be-8c19-0a5bc7d7fc7e.png" width="100%"></img></br>
- 주의해야할 건 05번째줄에서 if(nxt[addr]!=-1)이라는 처리가 들어간건데, 맨 마지막 원소의 뒤에 새 원소를 추가하는 상황이라면 "삽입할 위치의 다음 원소"가 존재하지 않습니다.
- 그런데도 pre[nxt[addr]] = unused; 로 써버리면 pre[-1]에 접근할 수 있습니다.
- 따라서 nxt[addr] 이 -1이 아닐 때만 pre[nxt[addr]]에 unused를 대입해야 합니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136899881-4a0dc372-c458-466e-9a48-755d680cae94.png" width="100%"></img></br>
- 이 두 과정만 하면 삭제가 끝납니다.
- 지금 보면 정작 삭제할 위치인 1번지에서는 dat, pre, nxt는 전혀 건드리지 않는 것을 볼 수 있는데, 앞으로 이 값들은 아무 의미가 없습니다.
- 제거된 원소고, 앞으로 그 어떤 nxt나 pre도 1번지를 가리키지 않을 것이기 때문입니다. 
- 이런 상황이니, 굳이 dat, nxt, pre 값을 -1 과 같은 다른 값으로 덮을 필요가 없고 그냥 내버려두면 됩니다. 
- 대신 이러한 구현 방법 때문에 야매 연결 리스트에서는 제거된 원소가 프로그램이 종료될 때 까지 메모리를 점유하고 있게 되고, 그렇기 때문에 실무에서는 사용할 수 없는 구현 방식입니다. 
- 하지만 알고리즘 문제에서는 insert의 횟수가 10만 번 혹은 100만 번과 같이 제한이 있기 마련이고, 그럴 때에는 그냥 배열을 제한에 맞춰 넉넉하게 잡고, 이 야매 연결 리스트를 사용하면 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136900237-30b794f3-08b2-4fd7-909a-0ac52d2ad219.png" width="100%"></img></br>
- 왜 pre[addr]이 -1인지는 체크를 하지 않아도 되는지 한 번 고민하는 시간을 가져봐도 괜찮을 것 같습니다.
- 그 이유는 dummy node의 존재로 인해 그 어떤 원소를 지우더라도, pre[addr]이 -1이 아님이 보장이 되기 때문입니다. 
</br>

- insert, erase를 메꾼 전체 코드는 github에서 확인할 수 있습니다.
- 지금 제 구현에서는 제일 마지막 원소를 O(N)에 확인할 수 있는데, 조금만 바꾸면 제일 마지막 원소도 O(1)에 확인할 수 있게 만들 수 있습니다.
- 하지만 이 부분은 여러분에게 맡기겠습니다. (0번지의 pre가 마지막 원소를 가리키면 되지 않나...?)
</br>

<img src="https://user-images.githubusercontent.com/83942393/136900688-1b79e262-eb83-4e5f-b6d3-c9df02266f63.png" width="100%"></img></br>
- 우리의 기대를 져버리지 않고 STL에는 list가 있습니다.
- STL을 사용할 수 있는 상황이라면, 연결 리스트를 꾸역꾸역 구현하는 것보다 STL를 쓰는게 훨씬 더 편하니 STL list의 사용법을 익혀두면 좋습니다. 
</br>

- 일단 STL list 에서 push_back, pop_back, push_front, pop_front 는 모두 O(1)이고, 우리가 이전에 '번지'라는 개념을 사용했듯, 여기서는 iterator 가 주소 역할을 합니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136901560-61bf85a8-280a-4447-8526-4074190ddbbc.png" width="80%"></img></br>
- 이제부터 연습문제를 풀어보겠습니다.
- [BOJ 1406번: 에디터](https://www.acmicpc.net/problem/1406) 문제를 사이트에 들어가서 확인해주세요. 
- 연결 리스트가 쓰이는 문제는 크게 응용해서 낼만한게 없고, 지금 문제와 같이 원소들을 돌아다니면서 이동하다가 삭제나 삽입이 필요한 문제들입니다.
- 그런데, 만약 N이 5000 정도로 작다면 그냥 O(N^2)로 짜도 통과되니 아무래도 우리에게 더 익숙한 vector로 구현을 하면 됩니다.
- 하지만 지금은 N이 굉장히 커서, 연결 리스트를 이용해 구현을 해야 합니다. 
- STL list와 야매 연결 리스트 둘 다를 이용해서 풀어보는 것을 추천드립니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136913520-7ca50963-b547-4e6b-b119-26f5c7efece4.png" width="100%"></img></br>
- STLlist를 이용한 코드입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136913626-8198ee52-64fa-41ec-9f57-3b36866fffd4.png" width="100%"></img></br>
- 두 번째는 야매 연결 리스트를 이용한 방법입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136913740-d9a02bd2-f513-4da8-b2b6-86944f9b966b.png" width="80%"></img></br>
- 그 다음 문제는 별다른건 아니고 면접이나 손코딩에서 물어볼만한 문제 3가지를 알려드리겠습니다.
- 정답을 고민해보세요.
- 효율적으로 구하라는 의미는 생각한 풀이의 공간 복잡도와 시간 복잡도를 생각해보라는 의미입니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136914006-d214af9b-3932-4eb8-b6ca-d02d09db7526.png" width="80%"></img></br>
- 이 문제의 정답은 별다른게 아니고 그냥 시작점을 따로 저장해뒀다가 동일한 노드가 나올 때 까지 계속 다음 노드로 이동하는 방식입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136914595-1ec98018-7599-44ba-9842-3bb80f61733f.png" width="80%"></img></br>
- 두 번째 문제를 풀어보겠습니다.
- 풀이를 떠올리셨나요? 이왕이면 공간복잡도 O(1)로 해결하는 방식을 고민해봅시다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136914567-ddf389b5-12f2-440e-96ed-db63506b0a83.png" width="80%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/136915140-4231b675-4599-467a-bac0-e1c12e08062e.png" width="80%"></img></br>
- 세 번째 문제를 풀어볼게요.
- 아마 공간 복잡도가 O(N)인 방법이 직관적으로 생각이 나실테지만, 공간복잡도가 O(1)인 방법이 존재합니다.
- 이 방법을 찾아보려고 노력해보면 좋겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136918684-67d2df27-51ba-4df2-b188-c29ee5bf6a28.png" width="80%"></img></br>
- 이 문제는 Floyd's cycle-finding algorithm 이라는 이름이 붙어있는 알고리즘으로 해결이 가능한데, 한 칸씩 가는 커서와 두 칸씩 가는 커서를 동일한 시작점에서 출발시키면, 사이클이 있을 경우 두 커서는 반드시 만나게 됩니다. 
- 반대로, 사이클이 없으면 두 커서가 만나지 못하고 연결 리스트의 끝에 도달하게 됩니다. 
- 이 방식을 이용하면 거치는 모든 노드를 저장할 필요가 없이 공간 복잡도 O(1)에 사이클의 존재 여부를 알 수 있습니다. 
- 사실 문제 2, 3번 정도면꽤 어려운 편이기 때문에 모른다고 해서 큰 일이 있는 건 아니지만 혹시 면접에서 얻어 걸리면 본인의 능지를 뽐낼 수 있으니까 너무 부담갖지는 마시고 가볍게 음미하고 넘어가겠습니다. 
