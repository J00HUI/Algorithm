## 9강 BFS
<img src="https://user-images.githubusercontent.com/83942393/137846669-2d8f6c7e-13ef-46c4-a602-a0862eab97ca.png" width="80%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/137846693-c8608a2c-5434-400d-b67b-4c06ba4e0b5b.png" width="80%"></img></br>
- BFS를 알아보기 전에 우리에게 익숙한 문제를 가지고 얘기를 시작해보겠습니다.
- 대충 물고기 사진을 하나 가지고 왔는데, 그림판의 페인트 기능을 이용하면, 물고기의 색을 바꿀 수 있습니다.
- 페인트 기능은 외부 윤곽선을 따라서 구분되는 영역의 색을 한꺼번에 바꾸는 거고, 이런걸 Flood Fill 이라고 부르기도 합니다.
</br>

- 그런데 이 Flood Fill 기능은 어떻게 구현할 수 있을까요?
- 일단 클릭한 칸의 상하좌우를 보며 나와 색이 같은지 확인하고, 같은 칸에 대해서 또 상하좌우로 확인하고....
- 뭔가 좀 막연합니다.
- 지금까지 배운 지식으로는 이 기능을 구현하는 게 쉽지 않지만, 이번에 배울 BFS라는 알고리즘을 가지고 해결할 수 있게 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137846870-68723d8b-0e77-4c37-8b82-ea55ce8dbcce.png" width="80%"></img></br>
- BFS는 여기 적힌 대로 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘입니다.
- 대체 너비를 우선으로 방문한다는게 뭔 소리지...싶을 텐데, 달리 어떻게 설명할 방법이 없습니다.
</br>

- 왜냐하면 원래 BFS는 그래프라는 자료구조에서 모든 노드를 방문하기 위한 알고리즘입니다.
- 여기서 말하는 그래프는 우리가 흔히 아는 왼쪽과 같은 형태의 그래프가 아닌, 오른쪽 모양의 그래프이고, 정확한 정의는 정점과 간선으로 이루어진 자료구조입니다. 
</br>

- 그렇기 때문에 BFS를 정확하게 이해하려면 그래프 자료구조에 대한 이해가 선행되어야 하는데, 그건 배보다 배꼽이 더 큰 느낌입니다.
- 그래서 BFS를 엄밀하게 정의할 수는 없지만, 실제로 어떻게 동작하는지를 보면서 다차원 배열에서의 BFS를 이해해보도록 하겠습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137847203-bc30a06b-4be2-4c05-9e66-f1dabf8286cb.png" width="80%"></img></br>
- 이전 강의 자료에서는 마치 설명서처럼 방법을 글로 먼저 설명해두었는데, 생소한 내용이다 보니 설명을 봐도 전혀 감이 올 것 같지 않습니다. 
- 그래서 그냥 실제 BFS를 돌리는 걸 한 번 보고 가겠습니다.
- 저희의 목표는 (0,0)과 상하좌우로 이어진 모든 파란색 칸을 확인하는 것입니다.
- 이 문제를 BFS로 어떻게 해결하는지 보겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137847330-f1c9d6b0-55c3-4291-b0ad-a5dce937c6b1.png" width="80%"></img></br>
- 우선 BFS 알고리즘에서는 좌표를 담을 큐가 필요합니다.
- BFS 알고리즘이 시작되면, 우선 (0,0)에 방문했다는 표시를 남기고 해당 칸을 큐에 넣습니다.
- 이 초기 세팅이 끝난 후에는 큐가 빌 떄까지 계속 큐의 front를 빼고 해당 좌표의 상하좌우를 살펴보면서 큐에 넣어주는 작업을 반복하게 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137847471-25436102-e5a2-4b59-8081-5c50b134b6c9.png" width="80%"></img></br>
- 큐의 front 는 (0,0)이고, pop을 합니다.
- 그리고 (0,0)의 상하좌우 칸을 보고, 이 중에서 아직 파란색 칸이면서, 아직 방문하지 않은 칸을 찾습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137847577-109d5a9f-5b8f-4a2c-81a2-9f57e38e9c07.png" width="80%"></img></br>
- (0,1)과 (1,0)은 모두 파란 칸이면서, 아직 방문하지 않았습니다.
- 이 2개의 칸에 방문했다는 표시를 남기고 큐에 넣습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137847641-1a1c0ba1-0a62-4f45-a9c7-2f9a4782603c.png" width="80%"></img></br>
- 다음으로 넘어갑니다.
- 현재 큐의 front는 (0,1)이고 pop을 합니다.
- 이번에도 (0,1)의 상하좌우 칸을 확인합니다.
- 이 칸들 중에서 (0,0)은 파란 칸이지만, 이미 방문을 했고, (1,1)은 빨간 칸입니다.
- 유일하게 (0,2)만 파란색 칸이면서, 아직 방문하지 않은 칸이므로 (0,2)에 방문했다는 표시를 남기고 큐에 넣습니다. 
</br>

- 계속 이런식으로 큐의 front를 pop하고 인접한 칸 중에서 방문하지 않은 파란색 칸에 표시를 남기고 큐에 넣어주면 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137847795-a4479cc0-4415-4a42-a3eb-9d2e5fc4c63e.png" width="80%"></img></br>
- 이렇게 큐가 빈 순간, 과정은 종료되고 (0,0)과 상하좌우로 이어진 모든 파란 칸을 방문했음을 알 수 있습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137847976-138f793c-0b3b-49a6-8f4c-958f240ec5ae.png" width="80%"></img></br>
- BFS의 시간복잡도를 생각해보면, 방문 표시를 남기기 때문에 모든 칸은 1번씩만 들어가게 됩니다.
- 그렇기 때문에 시간복잡도는 칸이 N개일 때 O(N)이 됩니다.
- 만약 행이 R개이고, 열이 C개이면 O(RC)가 될 것입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137848103-fb51f891-a2fa-4a8c-99a6-b93110fce571.png" width="100%"></img></br>
- BFS 구현을 다루기 전에 코드에서 쓰이게 될 STL을 하나 소개해 드리겠습니다.
- utility 헤더에 있는 pair인데, pair을 이용하면 두 자료형을 묶어서 가지고 다닐 수 있습니다.
- make_pair로 값을 넣어줄 수도 있고, C++11 이상에서는 중괄호를 써서 쉽게 해결할 수 있습니다.
- 또 pair에는 미리 대소관계가 정의되어 있어 편합니다.
- 알아서 앞쪽의 값을 먼저 비교하고, 뒤쪽의 값을 비교합니다.
</br>

- BFS를 구현할 때, 큐에 좌표를 넣어야 하는데, 이때 pair를 쓸 것입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137848288-9e279099-f9a4-4c0a-816c-289748fae4d9.png" width="100%"></img></br>
- BFS는 어느 정도 정석적인 구현이 있어서 지금 보여드릴 코드를 거의 외우다시피 해도 괜찮습니다.
- 특히 삼성 A형을 치기 위해서는 BFS가 정말 숙달되어 있어야 하는데, 어느 정도냐면 자고 있다가 누가 툭 쳐서 BFS를 짜라고 시켜도 한 5분내로 기본 틀을 좌르륵 쳐낼 수 있어야 합니다. 
</br>

- 일단 코드를 보겠습니다.
- 일단 03, 04번째 줄에서 #define을 해놓은 건 pair를 조금 더 편하게 쓰기 쓰기 위함인데, first/second 대신 t.X/t.Y로 쓰고 싶어서 저렇게 했습니다.
- 그다음 쭉 있는 변수들의 역할이 궁금할 텐데 하나씩 설명을 드리겠습니다. 
- board는 말 그대로 판을 의미합니다. 
- 1이면 파란 칸이고 0이면 빨간 칸이라고 생각하면 됩니다. 
- 그리고 vis는 방문 여부를 저장할 변수입니다. 
- 칸 위에 올리던 동그라미를 코드 상에서는 vis 값을 1로 변경함으로써 처리하는 것입니다. 
- 그리고 n과 m은 각각 행과 열의 개수를 의미하고, dx와 dy는 상하좌우를 영리하게 처리하기 위한 변수입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137848708-8f2f2c48-8ec0-4d1b-a22c-3a64733da7d1.png" width="80%"></img></br>
- 구현을 해보실 때 자주하는 실수를 몇 개 짚고 가겠습니다.
</br>

- 첫 번째로, 시작점을 큐에 넣긴 하는데, 방문했다는 표시를 남기지 않은 채 진행하는 경우가 있습니다.
- 이렇게 되면, 시작점을 두 번 방문할 수가 있습니다.
</br>

- 두 번째는 큐에 넣을 때 해당 칸에 방문했다는 표시를 남기지 않고 빼낼 때 남기는 경우인데, 이렇게 되면 같은 칸이 큐에 여러 번 들어가게 되어 시간 초과나 메모리 초과가 발생할 수 있습니다. 
- 특히 이건 보통 예재로 주는 작은 케이스에서는 잘 돌아가다가 실제 제출을 했을 때 터지는 경우가 많기 때문에 주의해야 합니다. 
</br>

- 세 번째는 앞의 코드에서 있던 nx, ny가 배열 바깥으로 벗어났는지에 대한 루틴을 아예 빼먹었거나, 아니면 이상하게 구현을 한 상황을 말합니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137849005-98a38cdb-76a7-45a2-92cd-3ab46d665642.png" width="80%"></img></br>
- 첫 번째 경우는 크게 어렵지는 않은게, 그냥 큐에서 pop을 몇 번하는지만 세면 끝입니다.
- 문제는 두 번째인데, 지금 나타낸 그림은 주어진 예제입니다.
- 여기에서 4개의 그림을 어떤 식으로 찾아야 할까요?
- 이 부분은 이중 for문을 돌면서 BFS의 시작점이 될 수 있는 곳을 찾으면 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137849230-3a8057cc-3955-4a89-b9e7-7365fcffef55.png" width="80%"></img></br>
- 일단 (0,0)에서 BFS를 시작하면, 크기가 4인 그림이 찾아질 것입니다.
- BFS를 돌고 나면, 방문 표시도 적절하게 남게 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137849329-208907ed-cc97-44f7-831f-260261cb6168.png" width="80%"></img></br>
- 그리고 그 후로 (0,1)이 시작점이 될 수 있는지를 보면, (0,1)은 파란 칸이지만 이미 방문을 했으니 여기서 또 BFS를 돌리면 안되겠죠. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137849419-ba93a0b9-5f49-4d32-be51-730259c815cf.png" width="80%"></img></br>
- 다음에는 (0,2)인데 여기는 애초에 빨간 칸이니 거릅니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137849452-0cb41eb9-b099-4a6f-a096-7397e8278964.png" width="80%"></img></br>
- 그 다음 (0,3)은 파란 칸이고, 아직 방문을 하지 않았으니 새로운 그림입니다.
- 그렇기 때문에 여기서 BFS를 시작합니다.
</br>

- 이와 같이 이중 for 문으로 각 칸이 BFS의 시작점이 될 수 있느지를 체크해주면, 도화지의 있는 모든 그림을 찾아낼 수 있습니다. 
- 그리고 여기서도 결국 각 칸은 큐에 딱 한번씩만 들어가므로, 시간 복잡도는 칸의 갯수만큼만 필요합니다.
- 이 문제에서는 O(nm)입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137849665-b611962f-405e-4676-8b89-0633f895b2a4.png" width="100%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/137849696-80a48c71-afdf-4f77-89a1-a0bb87227dd4.png" width="80%"></img></br>
- BFS로 flood fill을 수행하는 것을 같이 살펴봤는데, flood fill 말고도 정말 다양한 응용이 있고, 안타깝게도 BFS는 코딩테스트 단골 문제이기 때문에, 이런 응용들을 모두 잘 알고 있어야 합니다. 
- 그 응용 중에 첫 번째로, 다차원 배열에서의 거리 측정을 보겠습니다. 
- BOJ 2178번 미로탐색 문제를 확인해보세요.
</br>

- 문제를 보시면, 이 문제는 미로의 좌측 상단으로부터 우측 하단으로 가는 최단 경로의 길이를 찾는 문제입니다. 
- 그리고 BFS를 이용해 시작점에서 연결된 다른 모든 점으로의 최단 경로를 찾을 수 있습니다.
</br>

- 이 성질을 이해하기 위해 BFS의 과정을 다시 살펴보겠습니다.
- 지금 상황은 (0,0)에서 BFS를 도는 상황인데, 뭔가 (0,0)에서 사방으로 퍼져 나가는 것과 같은 느낌이 들지 않나요?
- 감이 잘 안온다면 다음 슬라이드를 같이 보겠습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137850093-44dbeed6-c1de-4a1b-bdc2-d4c371233062.png" width="80%"></img></br>
- 이번에는 방문했다는 표시 대신에, 각 칸들에 (0,0)까지의 거리를 적어놨는데 눈에 들어오는 게 있나요?
- 빨간색 칸은 현재 보는 칸이고, 검정색 칸은 추가되는 칸인데, 현재 보고 있는 칸으로부터 추가되는 인접한 칸은 거리가 현재 보는 칸보다 1만큼 더 떨어져 있습니다. 
- 이 성질을 활용하면, 우리는 단순히 상하좌우로 연결된 칸들을 방문하는 것에서 끝나는게 아니라, 시작점과의 거리를 전부 계산할 수 있습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137850796-c9d914e0-ca1a-4c80-9b2c-c56a1c3b2640.png" width="100%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/137850863-e7a6ddcd-e104-4d5e-bec3-5cae53260741.png" width="80%"></img></br>
- BFS로 거리를 잴 수 있는 것도 알았으니, 다음 응용으로 넘어가겠습니다.
- BOJ 7576 토마토 문제를 확인하고 오세요.
- 일단 이 문제가 BFS 문제라는 걸 보고 캐치할 수 있으셨는지 궁금합니다.
- 토마토가 익어가는 상황 자체가 BFS를 하는 것과 똑같기도 하고, 토마토가 다 익기 까지 필요한 최소 일수를 구하려면, 모든 익지 않은 토마토들에 대해 가장 가깝게 위치한 익은 토마토까지의 거리를 구해야한다는 관점에서 살펴봐도 마찬가지로 BFS를 활용할 수 있겠다는 생각이 듭니다. 
</br>

- 만약 익은 토마토가 1가 였다면, 앞의 미로 탐색 문제랑 비슷하게 익은 토마토가 있는 곳을 시작점으로 해서 BFS를 돌려 쉽게 해결이 가능할텐데, 이 문제에서는 익은 토마토의 개수가 여러 개 일수 있습니다. 
- 각 익은 토마토들에 대해 해당 위치를 시작점으로 하는 BFS를 한번씩 다 돌리는 방법을 떠올릴 수 있지만, 그러면 BFS의 시간복잡도가 O(NM)이고, 익은 토마토 또한 최대 NM개가 있을 수 있으니 총 O(N^2M^2)이 되어 시간 내로 해결이 안될 것입니다. 
</br>

- 지금까지의 상황을 다시 정리해보면, 우리는 지금 시작점이 여러 개인 BFS를 들 수 있어야 합니다. 
- 그리고 해결법은 의외로 간단한데, 그냥 모든 시작점을 큐에 넣고 앞에서 한 것과 똑같이 BFS를 돌면 끝입니다.
- 지금 슬라이드에서의 그림을 보면, 파란색은 익지 않은 토마토, 초록색은 익은 토마토, 빨간 색은 빈칸을 의미합니다.
- 현재 익은 토마토가 2개가 있는데, 그 2개를 큐에 넣어두고 BFS를 돌리면 이렇게 자연스럽게 거리가 잘 구해지게 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137853778-5cc21223-3855-4d8a-8fe2-b3a10479fce7.png" width="100%"></img></br>
- 이렇게 토마토 문제를 처리할 수 있습니다.
- 참고로 BOJ 7569번: 토마토 문제는 거의 똑같은데 3차원 입니다.
</br>

- 3차원이라고 해서 크게 다를건 없고, 단지 배열이 3차원이고 6개의 인접한 칸을 처리하기 위해 dx, dy, dz가 필요하게 됩니다. 
- 이 문제는 여러분에게 맡기겠습니다.
- 구현할 때 STL tuple 이라고 하는 것을 이용하면 좋습니다.
- int graph[z][y][x]
</br>

<img src="https://user-images.githubusercontent.com/83942393/137855879-014823ba-56f8-4e88-a61f-67e97638f614.png" width="80%"></img></br>
- 그리고 이 문제를 풀 때에는 쓰이지 않았지만 알아둘 필요가 있는 BFS 의 성질이 하나 더 있습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137855971-a1876241-aca8-4b0f-81d6-4d1e0521e0da.png" width="80%"></img></br>
- 거리가 1인 칸들이 빠지고, 2인 칸들을 볼 때면, 3인 칸들이 쭉 추가가 될 것입니다.
- 전체적인 큐의 모양을 확인해보시면, 이와 같이 BFS를 돌 때 큐에 쌓이는 순서는 반드시 거리 순이게 됩니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137856066-60326f09-81dd-41c9-b87c-413d95f0548f.png" width="80%"></img></br>
- 이제 응용 4개 중에 절반을 끝냈습니다.
- BOJ 4179번 불! 묹를 확인해보세요.
</br>

- 지금까지 배운 내용을 잘 이해했다면, 불의 전파를 BFS로 처리할 수 있음을 알 수 있을 것입니다.
- 그런데, 지금은 지훈이의 탈출도 같이 처리를 해주어야 하고, 이게 꽤 어렵습니다.
- 일단 결론적으로 말해 이런 문제는 불에 대한 BFS와 지훈이에 대한 BFS를 모두 돌림으로서 해결이 가능합니다.
</br>

- 먼저 지훈이는 신경쓰지 말고 불에 대한 BFS를 돌려서 미리 각 칸에 불이 전파되는 시간을 다 구해둡니다.
- 두 번째의 맴이 바로 각 칸에 불이 전파하는 시간입니다.
</br>

- 그 다음에는 지훈이에 대한 BFS를 돌리며 지훈이를 이동시킵니다.
- 이 때 만약 지훈이가 특정 칸을 x 시간에 최초로 방문할 수 있는데, 그 칸에 x시간이나 그 이전에 불이 붙는다면 그 칸을 못가게 됩니다. 
</br>

- 예를 들어, **으로 마킹한 칸을 보면, 지훈이는 저 칸에 2시간이 될 때 방문합니다.
- 그런데 불은 이미 1시간만에 전파되었기 때문에 지훈이는 저 곳을 갈 수 없습니다.
- \*, \*\*\*으로 마킹한 칸도 마찬가지 이유로 지훈이가 갈 수 없는 칸입니다.
</br>

- 원래 BFS의 구현에서는 큐 안에서 ny, nx를 살펴볼 때, 방문했는지 여부를 vis[ny][nx]가 true인지 혹은 dist[ny][nx]가 0 이상인지 확인하고, 이미 방문한 칸이라면 continue를 합니다.
- 이 문제에서는 추가로 해당 칸에 불이 붙은 시간을 확인해서 필요에 따라 continue를 하면 됩니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137856991-6eecdf62-0ff9-435f-ada7-493116b7433e.png" width="100%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/137857038-424c35b7-06c7-42d7-9017-266abad66fb8.png" width="100%"></img></br>
- 이렇게 시작점이 두 종료인 문제를 해결할 수 있게 됩니다.
- 그런데 시작점이 두 종류인 문제에 관해서 저희가 생각해야 할 점이 사실 추가로 있습니다. 
- 지금 이 방식이 가지고 있는 문제는 무엇인가 하면, 지금은 지훈이의 이동은 불의 전파에 영향을 받지만, 불의 전파는 지훈이의 이동에 영향을 받지 않아서 불만 먼저 전파를 쭉 시키는게 가능했습니다. 
- 그런데 예를 들어 시작점이 A, B 두 종류가 있고, A의 전파에 B가 영향을 주고, B의 전파에도 A가 영향을 준다고 해봅시다. 
- 지금 이 문제에서 지훈이와 불이 아니라, 불과 소방수 내지는 불과 물이 전파되는 문제여서 둘이 상호작용이 발생한다고 생각을 하는 거죠.  
</br>

- 그런 상황을 생각해보면, 어느 하나를 먼저 끝까지 전파시키는게 불가능합니다. 
- 제가 출제했던 18809 문제가 딱 그런 문제입니다.
- 아쉽게도 이 문제는 백트래킹 기법을 추가로 알고 있어야 해결이 가능하기 떄문에 당장 풀어볼 수는 없지만, 두 종류의 BFS에서 BFS를 돌 때 어느 하나가 독립적이지 않고 서로에게 영향을 준다면 지금 보여드린 이 방법으로는 해결할 수 없다는 것을 꼭 이해하셔야 합니다. 
- 그런 상황에서는 시간 순으로 A와 B를 동시에 진행시켜야 합니다. 
</br>

- 이 부분은 충분히 생각해볼 가치가 있고, 두 종류의 시작점 문제를 몇 개 풀다보면 지금 제가 한 얘기가 더 명확하게 이해가 갈 것입니다. 
- 그때 다른 사람의 코드를 찾아보거나 직접 고민하면서 시간 순으로 A와 B를 동시에 진행시킨다는 의미를 이해해보면 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137857863-cc24c070-7a7f-4c17-b53c-daa0b15f833d.png" width="80%"></img></br>
- 드디어 마지막 BFS입니다.
- BOJ 1697 숨바꼭질 문제를 한 번 보고 오시면, 지금까지 다뤘던 문제들이랑은 느낌이 많이 다른 것을 확인할 수 있습니다. 
- 지금까지는 죄다 2차원 배열 형태에서 상하좌우로 움직이는 모양새였는데, 얘는 전혀 다릅ㄹ니다. 
- 그래서 이게 BFS랑 관계가 있긴 한건가 싶을텐데, 이 문제도 BFS입니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137858049-e7d0fecc-4f04-45a2-9d0a-678620a063b7.png" width="80%"></img></br>
- 약간의 창의성을 발휘해서, 위와 같이 이 문제도 수빈이가 x에 있다고 할 때, x-1, x, 2x로 이동하는 것을 BFS로 처리할 수 있겠다는 생각을 해볼 수 있습니다.
- 수빈이가 예제처럼 5에 있었다고 치면 5에서 BFS를 시작하고, 5에서 갈 수 있는 4, 6, 10은 거리가 1이 되느 것입니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/137858294-19e368ec-42a1-423d-b89c-ec72e99ab258.png" width="80%"></img></br>
- 이제 BFS는 충분히 익숙해지셨을 것 같아서 큐는 안그려놨습니다.
- 이렇게 BFS를 돌다가 동생이 있는 위치의 값이 써지게 되면, 문제에서 원하는 답을 알 수 있게 됩니다.
</br>

- 그런데 사실 한 가지 더 고민해야 할 문제가 있는데, BFS의 범위를 어디까지로 해야할까요? 
- 0부터 100,000으로 하면 되는거 아닌가하고 쉽게 생각을 하셨을수도 있는데, 문제를 보시면 수빈이와 동생의 위치가 0에서 100,000 사이라고 했지 수빈이가 이동 중에 반드시 0에서 100,000 사이에만 있어야한다는 조건은 없습니다.
- 예를 들어 100,000 밖으로 나갔다가 다시 안으로 올 수도 있습니다. 그래서 이 부분을 고려할 필요가 있습니다.
</br>

- 일단 음수로 갈 일은 없을 것입니다. 
- 그건 진짜 절대 가장 빠른 경로가 될 수 없기 때문입니다. 
- 그리고 100,000 바깥으로 나갈 수 있겠지만 일단 한 번 나갔다면 그 이후로는 -1만 계속 할 것입니다.
- 그렇기 때문에 동생을 가장 빠르게 찾아나가는 상황에서는 아무리 멀리가도 200,000을 넘어가지는 않습니다.
</br>

- 이러한 생각을 거쳐서 0에서 200,000 사이에서만 BFS를 돌려도 답을 구하는데는 문제가 없음을 알 수 있게 되고, 여기서 더 깊게 생각을 해보면 사실 100,000을 나가는 것 자체가 손해라는 것을 알 수 있습니다
-  +1로 100,000을 탈출하는건 정말 바보짓이고, x2로 100,000을 탈출하는 상황이 있을 수 있겠다 싶지만, x2를 한 후 -1을 여러번 할 바에야 -1을 먼저 하고 x2를 하는게 더 낫기 때문입니다.
</br>

- 지금 설명이 잘 이해가 가지 않을 수 있습니다. 
- 이해가 가지 않더라도 상관은 없지만 이 문제에서 당연히 수빈이가 0에서 100,000 사이에서만 움직인다고 멋대로 가정을 하고 풀면 안된다는 점은 꼭 짚고 넘어가면 좋겠습니다. 
- 이 문제에서는 운 좋게 논리적으로 생각을 했을 때 수빈이가 0에서 100,000 사이에서만 움직이게 되었지만, 다른 문제에서는 멋대로 가정한 것 때문에 말아먹을수도 있습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/137858854-8e2eca9f-7288-4a26-8c66-9fa726262fff.png" width="100%"></img></br>
- 구현에서 크게 어려울 건 없을 것 같습니다. 
- 17번째 줄에서 range-based for를 이용했고, 구현 흐름은 늘 보던 것들의 반복입니다. 
