## 3강 배열

<img src="https://user-images.githubusercontent.com/83942393/136539662-840bf583-d964-4bbd-9f51-e090b05b3728.png" width="80%"></img></br>
- 면접을 대비하는 중이라면 어딘가에 적어두고 암기하는 것도 괜찮을 것 같습니다. 
- 2.아직 다른 자료구조를 배우지 않아서 비교를 할 수가 없는데, 다른 자료구조들을 배우고 나면 이 소리가 무슨 의미인지 알 수 있습니다.
- 3.메모리 상에 데이터들이 붙어있으니까 Cache hit rate가 높습니다. 
- 특징들을 간략하게 살펴봤는데, 1번 성질은 저희가 너무 당연하게 활용했던 성질이고, 2번, 3번, 4번 성질은 굳이 신경쓰지 않아도 코딩테스트를 칠 때는 별로 상관 없습니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136540501-2fd5565c-6575-44b7-9c2a-70fe5ef94287.png" width="80%"></img></br>
</br>

<img src="https://user-images.githubusercontent.com/83942393/136540508-724faf3f-89e8-41a3-9aff-d0853881645a.png" width="100%"></img></br>
- c++ 에서의 배열은 워낙 간단한 구조여서 특별한 팁은 없는데, 전체를 특정 값으로 초기화할 때 어떻게 하면 효율적으로 할 수 있는지만 짚고 넘어가겠습니다.
</br>

- 제일 짤막한 건 cstring 헤더에 있는 memset 함수를 활용하는 방식입니다.
- 그런데, memset 함수는 실수할 여지가 굉장히 많습니다.
- 예를 들어 0이나 -1이 아닌 다른 값을 넣으면 오작동한다거나, 2차원 이상의 배열을 함수의 인자로 넘겨 그곳에서 memset을 하면 잘못 들어간다거나 하는 점들이 있습니다. 
- 그래서 memset은 비추천합니다.
</br>

- 두 번째로는 for 문을 돌면서 값을 하나씩 바꾸는 방식이고, 코드가 조금 투박하지만 실수할 여지가 없기 때문에 무난하고 좋습니다.
</br>

- 마지막 방식은 algorithm 헤더의 fill 함수를 이용하는 것이고, fill 함수는 실수할 여지도 없고 코드고 짧으니 익숙해진다면 가장 추천하는 방식입니다.
- fill_n(a, 21, 0) 도 있습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136541695-82b707f9-db96-421c-aa32-ebf830564141.png" width="100%"></img></br>
- vector는 배열과 거의 동일한 기능을 수행하는 자료구조로, 배열과 마찬가지로 원소가 메모리에 연속하게 저장되기 때문에 O(1)에 인덱스를 가지고 각 원소로 접근할 수 있습니다. 그런데, vector는 배열과 달리 크기를 자유자재로 늘이거나 줄일 수 있는 장점이 있습니다. 
</br>

- 일단 사용법은 상단의 [레퍼런스 사이트](http://www.cplusplus.com/reference/vector/vector/)에 들어가면 다 익힐 수 있고, 앞으로도 가능하면 설명글 보다는 직접 레퍼런스 사이트를 확인하면서 메소드들을 정확하게 익히는 게 낫긴 하지만, 익숙하지 않으면 솔직히 좀 힘드니까 직접 vector 를 사용한 예시 코드를 보여드리겠습니다.
</br>

- insert와 erase는 배열에서 우리가 구현한 것처럼 비슷하게 시간복잡도가 O(N)입니다. push_back, pop_back 은 제일 끝에 원소를 추가하거나 빼는 것이니 O(1)입니다. 
</br>

- vector에서 = 를 사용하면 deep copy가 발생합니다.
- 16번째 줄에서는 v4가 {1, 2, 4}가 되었고, 이후에 v4를 바꿔도 v3에는 영향을 주지 않습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136542606-62d90e27-7a28-4edd-be7b-27b0b2a15264.png" width="100%"></img></br>
- vector에 있는 모든 원소를 순회하려고 할 때, 아마 이전에 본 적이 없으실 range-based for loop를 이용할 수 있습니다. 
- 지금은 값을 바꾸지 않고 출력만 해서 상관이 없지만, 만약 int e:v1 이라고 하면 복사된 값이 e에 들어가고 int& e:v1이라고 하면 원본이 e에 들어갑니다. 
- 그렇기 때문에 int e:v1이라고 쓴 for문 내에서 e를 바꿔도 v1에는 영향이 가지 않지만, int& e:v1 이라고 쓴 for문 내에서는 e를 바꾸면 원본인 v1에서 실제 해당 원소의 값이 바뀌게 됩니다.
- 이 기능은 vector 뿐만 아니라, 나중에 배울 list, map, set 등에서 모두 사용할 수 있기 때문에 기억해두시면 좋은데, 다만 이 기능은 c++11 부터 추가된 기능입니다. 만약 코딩테스트가 c++11을 지원하지 않는다면 사용할 수 없습니다.
</br>

- 2020년 2월 기준으로 제가 아는 범위 안에서는 유일하게 삼성전자 SW 역량 테스트에서만 c++11을 지원해주지 않지만 시간이 지나면 삼성전자 SW 역량 테스트에서도 c++11을 지원해주지 않을까 싶습니다.
</br>

- 3번 코드는 큰 오류가 발생할 수 있습니다.
- 기본적으로 vector의 size 메소드는 시스템에 따라 unsigned int 혹은 unsigned long long 을 반환합니다.
- 그렇기 때문에 32비트 컴퓨터 기준으로 3번처럼 쓰면 v1이 빈 vector일 때 v1.size() -1 이 (unsigned int)0 - (int)1은 -1이 아니라 4294967295이 되어버립니다. 4294967295라는 이상한 값은 unsigned int overflow로 인해 생기게 됩니다.
- (unsigned int와 int를 연산하면 unsigned int 로 자동 형변환이 발생합니다. )
- 그러므로 아무것도 출력되는 것이 아닌, v1[0], v1[1], v1[2], ... 점점 i가 커지다가 어느 순간 런타임 에러가 발생하게 될 것입니다. 
</br>

- 정리하자면, vector에 있는 모든 원소를 순회하고자 한다면 range-based for loop 를 사용해도 되고 인덱스를 써서 하나씩 다 돌아도 상관이 없지만, size 메소드의 반환 값이 unsigned 이기 때문에 3번처럼 구현한다면 안된다는 것입니다.
</br>

<img src="https://user-images.githubusercontent.com/83942393/136546384-e8e263a3-d6f0-4f78-b3aa-fcbcf05a8000.png" width="80%"></img></br>
- 이제는 배열이 쓰이는 문제 몇 개를 다뤄보겠습니다.
- 일단 배열은 데이터를 자주 바꾸지 않고 그냥 쌓아두고 싶을 때 활용할 수 있습니다. 
- 그리고 사실 거의 대부분의 문제에서 일단 입력값을 저장해놓고 시작하는 일이 많기 때문에 입력을 담아두기 위해 배열을 사용하곤 합니다.
- 그래서 단지 데이터를 쌓아두는 용도 말고 인덱스에 해당하는 원소를 빠르게 접근하는 목적으로 배열을 사용하면 효율적인 문제를 소개하겠습니다.
</br>

- 첫 번째 문제는 BOJ 10808번: 알파벳 개수 문제입니다. BOJ에 들어가서 문제를 확인하고 구현을 끝낸 후에 돌아오도록 합시다. 

<img src="https://user-images.githubusercontent.com/83942393/136546752-41072fe6-c7d1-492d-a930-67644d364f43.png" width="100%"></img></br>
- freq 배열의 초기값은 0이어야 할텐데 전역에 선언하면 알아서 0으로 채워지니 따로 초기화하지 않았습니다.
- freq 가 지역 변수였다면 int freq[26]; 이라고만 할 경우 0이 아닌 다른 쓰레기값이 채워지기 떄문에 int freq[26] = {} 혹은 fill(freq, freq+26, 0); 과 같은 조치가 필요했을 것입니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136546976-52ce15d9-00ab-4c39-b566-48a81b9ca13e.png" width="80%"></img></br>
- 두 번째로 다룰 문제는 1강에서 시간 복잡도를 얘기하면서 다룬 문제입니다.
- 당시에는 이 문제를 이중 for 문으로 해결하는 O(N^2) 알고리즘을 제시했고, O(N) 알고리즘도 존재한다고 얘기를 살짝 하고 넘어갔는데, 이전 문제와 비슷한 느낌을 잘 이용하면 이 문제의 O(N) 풀이를 떠올릴 수 있습니다. 
</br>

<img src="https://user-images.githubusercontent.com/83942393/136547170-ed6caecf-77cd-4fa7-b9f1-39913c0f2c48.png" width="100%"></img></br>
